<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Tomoki Imai">
  <meta name="dcterms.date" content="2013-01-01">
  <title>Algorithm And Tips For Competitive Programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="library.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Algorithm And Tips For Competitive Programming</h1>
<h2 class="author">Tomoki Imai</h2>
<h3 class="date">2013</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#テンプレート"><span class="toc-section-number">1</span> テンプレート</a><ul>
<li><a href="#c"><span class="toc-section-number">1.1</span> C++</a></li>
<li><a href="#python"><span class="toc-section-number">1.2</span> Python</a></li>
</ul></li>
<li><a href="#算術型"><span class="toc-section-number">2</span> 算術型</a><ul>
<li><a href="#int"><span class="toc-section-number">2.1</span> int</a></li>
<li><a href="#long-long"><span class="toc-section-number">2.2</span> long long</a><ul>
<li><a href="#ビット演算"><span class="toc-section-number">2.2.1</span> ビット演算</a></li>
</ul></li>
<li><a href="#double"><span class="toc-section-number">2.3</span> double</a></li>
<li><a href="#char"><span class="toc-section-number">2.4</span> char</a></li>
<li><a href="#bool"><span class="toc-section-number">2.5</span> bool</a></li>
<li><a href="#補助関数"><span class="toc-section-number">2.6</span> 補助関数</a></li>
</ul></li>
<li><a href="#入出力"><span class="toc-section-number">3</span> 入出力</a><ul>
<li><a href="#cincout"><span class="toc-section-number">3.1</span> cin,cout</a><ul>
<li><a href="#cin"><span class="toc-section-number">3.1.1</span> cin</a></li>
<li><a href="#cout"><span class="toc-section-number">3.1.2</span> cout</a></li>
</ul></li>
<li><a href="#scanfprintf"><span class="toc-section-number">3.2</span> scanf,printf</a><ul>
<li><a href="#scanf"><span class="toc-section-number">3.2.1</span> scanf</a></li>
<li><a href="#printf"><span class="toc-section-number">3.2.2</span> printf</a></li>
</ul></li>
<li><a href="#高速化"><span class="toc-section-number">3.3</span> 高速化</a></li>
</ul></li>
<li><a href="#stdvector"><span class="toc-section-number">4</span> std::vector</a><ul>
<li><a href="#基本"><span class="toc-section-number">4.1</span> 基本</a></li>
<li><a href="#並び換え"><span class="toc-section-number">4.2</span> 並び換え</a><ul>
<li><a href="#sort"><span class="toc-section-number">4.2.1</span> sort</a></li>
<li><a href="#stable_sort"><span class="toc-section-number">4.2.2</span> stable_sort</a></li>
</ul></li>
<li><a href="#unique"><span class="toc-section-number">4.3</span> unique</a></li>
<li><a href="#rotate"><span class="toc-section-number">4.4</span> rotate</a></li>
<li><a href="#next_permutation"><span class="toc-section-number">4.5</span> next_permutation</a></li>
<li><a href="#座標圧縮"><span class="toc-section-number">4.6</span> 座標圧縮</a></li>
</ul></li>
<li><a href="#探索"><span class="toc-section-number">5</span> 探索</a><ul>
<li><a href="#全探索"><span class="toc-section-number">5.1</span> 全探索</a></li>
<li><a href="#二分探索"><span class="toc-section-number">5.2</span> 二分探索</a></li>
<li><a href="#三分探索"><span class="toc-section-number">5.3</span> 三分探索</a><ul>
<li><a href="#合計の重さxを達成するような組み合わせの数え上げ"><span class="toc-section-number">5.3.1</span> 合計の重さXを達成するような組み合わせの数え上げ</a></li>
</ul></li>
<li><a href="#ぐるぐる"><span class="toc-section-number">5.4</span> ぐるぐる</a></li>
</ul></li>
<li><a href="#文字列操作"><span class="toc-section-number">6</span> 文字列操作</a><ul>
<li><a href="#stdstring"><span class="toc-section-number">6.1</span> std::string</a><ul>
<li><a href="#部分列"><span class="toc-section-number">6.1.1</span> 部分列</a></li>
<li><a href="#検索"><span class="toc-section-number">6.1.2</span> 検索</a></li>
</ul></li>
<li><a href="#stringstream"><span class="toc-section-number">6.2</span> stringstream</a></li>
<li><a href="#再帰下降構文解析"><span class="toc-section-number">6.3</span> 再帰下降構文解析</a></li>
<li><a href="#ll1文法--再帰下降で書けるかどうか"><span class="toc-section-number">6.4</span> LL1文法(&lt;-&gt; 再帰下降で書けるかどうか)</a></li>
</ul></li>
<li><a href="#整数論"><span class="toc-section-number">7</span> 整数論</a><ul>
<li><a href="#最大公約数最小公倍数"><span class="toc-section-number">7.1</span> 最大公約数,最小公倍数</a><ul>
<li><a href="#最大公約数"><span class="toc-section-number">7.1.1</span> 最大公約数</a></li>
<li><a href="#最小公倍数"><span class="toc-section-number">7.1.2</span> 最小公倍数</a></li>
</ul></li>
<li><a href="#mod"><span class="toc-section-number">7.2</span> mod</a><ul>
<li><a href="#modの計算式について"><span class="toc-section-number">7.2.1</span> modの計算式について</a></li>
<li><a href="#冪乗のmod"><span class="toc-section-number">7.2.2</span> 冪乗のmod</a></li>
</ul></li>
<li><a href="#素数"><span class="toc-section-number">7.3</span> 素数</a><ul>
<li><a href="#エラトステネスの篩"><span class="toc-section-number">7.3.1</span> エラトステネスの篩</a></li>
<li><a href="#素因数分解"><span class="toc-section-number">7.3.2</span> 素因数分解</a></li>
</ul></li>
<li><a href="#コンビネーション"><span class="toc-section-number">7.4</span> コンビネーション</a></li>
<li><a href="#確率的なアレ"><span class="toc-section-number">7.5</span> 確率的なアレ</a></li>
<li><a href="#乱数"><span class="toc-section-number">7.6</span> 乱数</a></li>
<li><a href="#基数変換"><span class="toc-section-number">7.7</span> 基数変換</a></li>
<li><a href="#二次方程式"><span class="toc-section-number">7.8</span> 二次方程式</a></li>
<li><a href="#連立方程式"><span class="toc-section-number">7.9</span> 連立方程式</a></li>
<li><a href="#nと互いに素な数の個数"><span class="toc-section-number">7.10</span> nと互いに素な数の個数</a></li>
</ul></li>
<li><a href="#行列"><span class="toc-section-number">8</span> 行列</a><ul>
<li><a href="#基本要素"><span class="toc-section-number">8.1</span> 基本要素</a></li>
<li><a href="#基本演算"><span class="toc-section-number">8.2</span> 基本演算</a></li>
<li><a href="#基本操作"><span class="toc-section-number">8.3</span> 基本操作</a><ul>
<li><a href="#累乗"><span class="toc-section-number">8.3.1</span> 累乗</a></li>
<li><a href="#表示"><span class="toc-section-number">8.3.2</span> 表示</a></li>
<li><a href="#ベクトルとのかけ算"><span class="toc-section-number">8.3.3</span> ベクトルとのかけ算</a></li>
</ul></li>
<li><a href="#gauss-jordan"><span class="toc-section-number">8.4</span> Gauss-Jordan</a></li>
</ul></li>
<li><a href="#動的計画法およびそれに似たやつらtodo"><span class="toc-section-number">9</span> 動的計画法およびそれに似たやつら。(TODO)</a><ul>
<li><a href="#lcs"><span class="toc-section-number">9.1</span> LCS</a></li>
<li><a href="#lis"><span class="toc-section-number">9.2</span> LIS</a><ul>
<li><a href="#onlogn"><span class="toc-section-number">9.2.1</span> O(NlogN)</a></li>
</ul></li>
<li><a href="#巡回セールスマン問題"><span class="toc-section-number">9.3</span> 巡回セールスマン問題</a></li>
<li><a href="#ナップサック問題"><span class="toc-section-number">9.4</span> ナップサック問題</a></li>
<li><a href="#ヒストグラム内の最大長方形のサイズ"><span class="toc-section-number">9.5</span> ヒストグラム内の最大長方形のサイズ</a></li>
<li><a href="#なんか長方形の和をもとめるやつ"><span class="toc-section-number">9.6</span> なんか長方形の和をもとめるやつ</a></li>
</ul></li>
<li><a href="#データ構造"><span class="toc-section-number">10</span> データ構造</a><ul>
<li><a href="#union-find"><span class="toc-section-number">10.1</span> Union-Find</a></li>
<li><a href="#ヒープ"><span class="toc-section-number">10.2</span> ヒープ</a></li>
<li><a href="#bitset"><span class="toc-section-number">10.3</span> bitset</a></li>
<li><a href="#分数"><span class="toc-section-number">10.4</span> 分数</a></li>
<li><a href="#セグメント木"><span class="toc-section-number">10.5</span> セグメント木</a><ul>
<li><a href="#普通の"><span class="toc-section-number">10.5.1</span> 普通の</a></li>
<li><a href="#lazy"><span class="toc-section-number">10.5.2</span> Lazy</a></li>
</ul></li>
<li><a href="#定数個のみを保持するpriority_queue"><span class="toc-section-number">10.6</span> 定数個のみを保持するpriority_queue</a></li>
</ul></li>
<li><a href="#グラフ"><span class="toc-section-number">11</span> グラフ</a><ul>
<li><a href="#構成要素"><span class="toc-section-number">11.1</span> 構成要素</a></li>
<li><a href="#ベルマンフォード"><span class="toc-section-number">11.2</span> ベルマンフォード</a></li>
<li><a href="#ダイクストラ"><span class="toc-section-number">11.3</span> ダイクストラ</a></li>
<li><a href="#ワーシャルフロイド"><span class="toc-section-number">11.4</span> ワーシャルフロイド</a></li>
<li><a href="#最小全域木"><span class="toc-section-number">11.5</span> 最小全域木</a></li>
<li><a href="#最大流"><span class="toc-section-number">11.6</span> 最大流</a></li>
<li><a href="#最小費用流"><span class="toc-section-number">11.7</span> 最小費用流</a></li>
<li><a href="#無向グラフにおける最小カット"><span class="toc-section-number">11.8</span> 無向グラフにおける最小カット</a></li>
<li><a href="#強連結成分分解"><span class="toc-section-number">11.9</span> 強連結成分分解</a></li>
<li><a href="#橋の列挙"><span class="toc-section-number">11.10</span> 橋の列挙</a></li>
<li><a href="#lowest-common-ancestor"><span class="toc-section-number">11.11</span> Lowest Common Ancestor</a></li>
</ul></li>
<li><a href="#幾何"><span class="toc-section-number">12</span> 幾何</a><ul>
<li><a href="#最近点対"><span class="toc-section-number">12.1</span> 最近点対</a></li>
</ul></li>
<li><a href="#ゲーム"><span class="toc-section-number">13</span> ゲーム</a><ul>
<li><a href="#nim"><span class="toc-section-number">13.1</span> Nim</a></li>
</ul></li>
<li><a href="#なんか最適化とか"><span class="toc-section-number">14</span> なんか最適化とか</a><ul>
<li><a href="#焼き鈍し"><span class="toc-section-number">14.1</span> 焼き鈍し</a></li>
</ul></li>
<li><a href="#いろんなデータ"><span class="toc-section-number">15</span> いろんなデータ</a><ul>
<li><a href="#階乗"><span class="toc-section-number">15.1</span> 階乗</a></li>
<li><a href="#数単位変換"><span class="toc-section-number">15.2</span> 数単位変換</a></li>
<li><a href="#bit"><span class="toc-section-number">15.3</span> bit</a></li>
<li><a href="#最低限の設定ファイル"><span class="toc-section-number">15.4</span> 最低限の設定ファイル</a><ul>
<li><a href="#vim用"><span class="toc-section-number">15.4.1</span> vim用</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="テンプレート"><span class="header-section-number">1</span> テンプレート</h1>
<p>各種バッドノウハウを含む。</p>
<h2 id="c"><span class="header-section-number">1.1</span> C++</h2>
<div class="sourceCode" include="cpp/template.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// compile in C++11. use -std=c++11.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;iomanip&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;valarray&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;list&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;bitset&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>
<span class="ot">#include &lt;complex&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>

<span class="co">// this require C++11</span>
<span class="ot">#include &lt;unordered_set&gt;</span>
<span class="ot">#include &lt;unordered_map&gt;</span>
<span class="ot">#include &lt;random&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define all(c) c.begin(),c.end()</span>
<span class="ot">#define repeat(i,n) for(int i=0;i&lt;static_cast&lt;int&gt;(n);i++)</span>
<span class="ot">#define debug(x) #x &lt;&lt; &quot;=&quot; &lt;&lt; (x)</span>
<span class="ot">#define dump(x) cerr &lt;&lt; debug(x) &lt;&lt; &quot; (L:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot;&lt;&lt; endl</span>

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;
<span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,<span class="dt">const</span> vector&lt;T&gt;&amp; vec){
    os &lt;&lt; <span class="st">&quot;[&quot;</span>;
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; v : vec){
        os &lt;&lt; v &lt;&lt; <span class="st">&quot;,&quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;]&quot;</span>;
    <span class="kw">return</span> os;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T input(){
    T t;cin &gt;&gt; t;
    <span class="kw">return</span> t;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
vector&lt;T&gt; input(<span class="dt">const</span> <span class="dt">int</span> N){
    vector&lt;T&gt; v(N);
    repeat(i,N) cin &gt;&gt; v[i];
    <span class="kw">return</span> v;
}



<span class="dt">int</span> main(){
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="python"><span class="header-section-number">1.2</span> Python</h2>
<div class="sourceCode" include="python/template.py"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>
<span class="co">#coding:utf-8</span>

<span class="im">from</span> __future__ <span class="im">import</span> division
<span class="im">from</span> __future__ <span class="im">import</span> print_function
<span class="im">from</span> __future__ <span class="im">import</span> unicode_literals

<span class="im">from</span> math <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> string <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> fractions <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> itertools <span class="im">import</span> <span class="op">*</span>

<span class="kw">def</span> main():
    <span class="cf">pass</span>

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre></div>
<h1 id="算術型"><span class="header-section-number">2</span> 算術型</h1>
<h2 id="int"><span class="header-section-number">2.1</span> int</h2>
<p>基本中の基本。<span class="math inline">\(10^{9}\)</span>くらい。こわいときにはlong longを使うことを推奨。</p>
<h2 id="long-long"><span class="header-section-number">2.2</span> long long</h2>
<p>大きい整数。<span class="math inline">\(10^{18}\)</span>?くらい。</p>
<h3 id="ビット演算"><span class="header-section-number">2.2.1</span> ビット演算</h3>
<p>ビットDPとかに使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 下から2番目のビットを立てる。1llと書くことに注意</span>
x |= (<span class="dv">1ll</span> &lt;&lt; <span class="dv">1</span>);

<span class="co">// 集合演算</span>
<span class="co">// 和</span>
ll z = x | y;
<span class="co">// 積</span>
ll z = x &amp; y;
<span class="co">// xor</span>
ll z = x ^ y;
<span class="co">// ループ</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
    <span class="co">// i番目が立っていれば</span>
    <span class="kw">if</span>(x &amp; (<span class="dv">1ll</span> &lt;&lt; i)){
        <span class="co">//something.</span>
    }
}

ll dp[<span class="dv">1</span> &lt;&lt; N][N];
dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
<span class="co">// Bitのほうが先!</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dv">1</span>&lt;&lt;N);i++){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
        <span class="co">//something.</span>
    }
}</code></pre></div>
<h2 id="double"><span class="header-section-number">2.3</span> double</h2>
<p>floatは使ってはだめ。</p>
<h2 id="char"><span class="header-section-number">2.4</span> char</h2>
<p>-128 ~ 127くらい。ちいさい。基本的には文字を入れるのに使う。vector&lt;char&gt;を<br />
vector&lt;bool&gt;の代わりに使ってもいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = <span class="st">&#39;a&#39;</span>;
<span class="co">//cctypeが必要。大文字に変換する。すでに大文字のときは何も起こらない。</span>
c = toupper(c);
<span class="co">//小文字に変換する。</span>
c = tolower(c);
<span class="co">//vector&lt;bool&gt;の代わり。</span>
vector&lt;<span class="dt">char</span>&gt; used(<span class="dv">10</span>,<span class="kw">false</span>);</code></pre></div>
<h2 id="bool"><span class="header-section-number">2.5</span> bool</h2>
<p>true(==1)とかfalse(==0)を入れるためだけに使う。ただしvector&lt;bool&gt;は使ってはいけない。</p>
<h2 id="補助関数"><span class="header-section-number">2.6</span> 補助関数</h2>
<p>上記の型に関する便利な関数。</p>
<p>床関数、天井関数、および四捨五入。返り値はdouble。cmathをincludeする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> x = <span class="fl">0.3</span>;
<span class="dt">int</span> f = floor(x); <span class="co">// -&gt; 0</span>
<span class="dt">int</span> c = ceil(x); <span class="co">// -&gt; 1</span>
<span class="dt">int</span> r = round(x) <span class="co">// -&gt; 0</span></code></pre></div>
<p>任意の場所で四捨五入したいときには、<span class="math inline">\(10^{n}\)</span>をかけて、roundした後に、<br />
<span class="math inline">\(10^{n}\)</span>で割ればいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> x = <span class="fl">0.123456789</span>;
<span class="co">//0.123</span>
<span class="dt">double</span> r = round(x*<span class="dv">1000</span>) / <span class="fl">1000.0</span>;</code></pre></div>
<h4 id="section"><span class="header-section-number">2.6.0.1</span> </h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">int</span> popcount(T x){
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">while</span>(x){
        x &amp;= x<span class="dv">-1</span>;
        ret++;
   }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h1 id="入出力"><span class="header-section-number">3</span> 入出力</h1>
<p>基本はcin,coutを使おう。</p>
<h2 id="cincout"><span class="header-section-number">3.1</span> cin,cout</h2>
<p>iostream,iomanipをincludeしておくこと。</p>
<h3 id="cin"><span class="header-section-number">3.1.1</span> cin</h3>
<p>基本的な使い方について。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;
cin &gt;&gt; n;
vector&lt;<span class="dt">int</span>&gt; V(n);
rep(i,n) cin &gt;&gt; V[i];</code></pre></div>
<p>こうすると、短く書ける。</p>
<p>入力の最後まで読む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;
<span class="kw">while</span>(cin &gt;&gt; n){
    <span class="co">//処理</span>
}</code></pre></div>
<p>n=0のとき終わりとかの場合は、条件に&amp;&amp;n!=0とかをつける。<br />
数値をカンマ区切りで読み込む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x,y;<span class="dt">char</span> c;
<span class="co">//cにカンマが入る</span>
cin &gt;&gt; x &gt;&gt; c &gt;&gt; y;</code></pre></div>
<p>冗長かもだけど、一番楽。<br />
空白とか含めて一行読む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string s;
getline(cin,s);</code></pre></div>
<p>改行文字は、sに入らず、かつ読み捨てされる。<br />
cinでは、改行文字は読み捨てないことに注意しよう。<br />
つまり、数値&lt;改行&gt;文字列&lt;改行&gt;を読みたいときには、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;string s;
<span class="co">// 数値</span>
cin &gt;&gt; n;
<span class="co">// 改行よみとばし</span>
cin.ignore();
<span class="co">// 文字列</span>
getline(cin,s);</code></pre></div>
<p>とする。cinは改行文字を残すので、ignoreでそれを読み捨てないといけない。<br />
また、ignoreの引数は読み捨てる文字数。引数なしの場合は1を渡したのと同等の効果がある。</p>
<h3 id="cout"><span class="header-section-number">3.1.2</span> cout</h3>
<p>有効数字等が設定されている問題は、必ず多めに出力すること。多めに出す分には大丈夫。</p>
<p>基本の使い方</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;vector&lt;<span class="dt">int</span>&gt; V(n);
cout &lt;&lt; n &lt;&lt; endl;
rep(i,n) cout &lt;&lt; V[i] &lt;&lt; <span class="st">&quot; &quot;</span>;
cout &lt;&lt; endl;</code></pre></div>
<p>以下主なiomanipの使い方</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n = <span class="dv">123</span>;<span class="dt">double</span> d = <span class="fl">1.23</span>;

<span class="co">//10進数 −&gt; 123</span>
cout &lt;&lt; dec &lt;&lt; n &lt;&lt; endl ;

<span class="co">//8進数 −&gt; 173</span>
cout &lt;&lt; oct &lt;&lt; n &lt;&lt; endl ;

<span class="co">//16進数 −&gt; 7b</span>
cout &lt;&lt; hex &lt;&lt; n &lt;&lt; endl ;

<span class="co">//16進数かつ、大文字 −&gt; 7B</span>
cout &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; n &lt;&lt; endl;

<span class="co">//10進数に戻す</span>
cout &lt;&lt; dec;

<span class="co">//幅が10になるようにする。デフォルトは右寄せ</span>
<span class="co">// -&gt; xxxxxxx123 (default)</span>
cout &lt;&lt; setfill(<span class="st">&#39;x&#39;</span>) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; right &lt;&lt; n &lt;&lt; endl;

<span class="co">// -&gt; 123xxxxxxx</span>
cout &lt;&lt; setfill(<span class="st">&#39;x&#39;</span>) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; left &lt;&lt; n &lt;&lt; endl;
<span class="co">// -&gt; 123yyyyyyy</span>
cout &lt;&lt; setfill(<span class="st">&#39;y&#39;</span>) &lt;&lt; setw(<span class="dv">10</span>) &lt;&lt; n &lt;&lt; endl;

<span class="co">//小数点以下10桁表示に。</span>
cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="dv">10</span>);

<span class="co">// -&gt; 1.2300000000</span>
cout &lt;&lt; d &lt;&lt; endl;
<span class="co">// -&gt; 12.3000000000</span>
cout &lt;&lt; <span class="dv">10</span>*d &lt;&lt; endl;

<span class="co">//小数点の表示を元に戻す</span>
cout.unsetf(ios::fixed);
<span class="co">// -&gt; 1.23</span>
cout &lt;&lt; d &lt;&lt; endl;</code></pre></div>
<p>基本的には、引数のあるマニピュレータの効果は保存される。</p>
<h2 id="scanfprintf"><span class="header-section-number">3.2</span> scanf,printf</h2>
<p>C++では、cstdioをinclude。複雑な書式とかが必要なときにはこっちを使うといいかもしれない。</p>
<h3 id="scanf"><span class="header-section-number">3.2.1</span> scanf</h3>
<p>基本的な使い方</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n;<span class="dt">char</span> tmp[<span class="dv">256</span>];
scanf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,&amp;n);
gets(tmp);</code></pre></div>
<p>stringに直接いれるのはだめ。scanfはcinと同様に改行を残す。getlineするなら<br />
cin.ignore。getsするなら、直前のscanfで改行を読んでおく必要がある。<br />
また、scanfで改行を読むのでなく、直後にgetc(stdin)してもいい。</p>
<h3 id="printf"><span class="header-section-number">3.2.2</span> printf</h3>
<p>基本的な使い方</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n = <span class="dv">100</span>;
printf(<span class="st">&quot;n is </span><span class="ch">%d\n</span><span class="st">&quot;</span>,n);</code></pre></div>
<p>scanfとほとんど同様の使い方ができる。</p>
<table>
<caption>書式指定子</caption>
<thead>
<tr class="header">
<th style="text-align: left;">指定子</th>
<th style="text-align: left;">出力書式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">%c</td>
<td style="text-align: left;">文字</td>
</tr>
<tr class="even">
<td style="text-align: left;">%s</td>
<td style="text-align: left;">文字列</td>
</tr>
<tr class="odd">
<td style="text-align: left;">%d</td>
<td style="text-align: left;">符号付き10進整数</td>
</tr>
<tr class="even">
<td style="text-align: left;">%u</td>
<td style="text-align: left;">符号なし10進</td>
</tr>
<tr class="odd">
<td style="text-align: left;">%f</td>
<td style="text-align: left;">10進浮動小数点数</td>
</tr>
<tr class="even">
<td style="text-align: left;">%o</td>
<td style="text-align: left;">符号なし8進</td>
</tr>
<tr class="odd">
<td style="text-align: left;">%x</td>
<td style="text-align: left;">符号なし16進(Xなら大文字)</td>
</tr>
<tr class="even">
<td style="text-align: left;">%%</td>
<td style="text-align: left;">%記号</td>
</tr>
</tbody>
</table>
<h2 id="高速化"><span class="header-section-number">3.3</span> 高速化</h2>
<p>以下のコードをmain関数の最初に書くことで、cin,coutの速度が2倍程度になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ios::sync_with_stdio(<span class="kw">false</span>);
cin.tie(<span class="dv">0</span>);</code></pre></div>
<p>ただし、このコードはstdioとの同期を切るという意味なので、これを使うときにはprintfやscanfを使用してはだめ。</p>
<h1 id="stdvector"><span class="header-section-number">4</span> std::vector</h1>
<p>ここでは、配列のSTL版である、vectorの使いかたについて書く。<br />
ここに書かれている関数は、string等にも用いることができるものが多い。<br />
ちなみに、vector&lt;bool&gt;は使ってはいけない。bitsetや、vector&lt;char&gt;をつかうこと。<br />
また、all(vector)は、vector.begin(),vector.end()とdefineしている。</p>
<h2 id="基本"><span class="header-section-number">4.1</span> 基本</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//要素数10で、初期値は-1にする。</span>
vector&lt;<span class="dt">int</span>&gt; vec(<span class="dv">10</span>,<span class="dv">-1</span>);
<span class="co">//vecの最初から3つの要素をコピーする。</span>
vector&lt;<span class="dt">int</span>&gt; newvec(vec.begin(),vec.begin()<span class="dv">+3</span>);
<span class="co">//vecの最初から3つの要素を削除する。</span>
vec.erase(vec.begin(),vec.begin()<span class="dv">+3</span>);</code></pre></div>
<h2 id="並び換え"><span class="header-section-number">4.2</span> 並び換え</h2>
<h3 id="sort"><span class="header-section-number">4.2.1</span> sort</h3>
<p>C++のsortは、<span class="math inline">\(O(n \log n)\)</span>で、introsort。何も指定しない場合には昇順にソートされる。<br />
注意すべきなのは、C++11では、最悪ケースで<span class="math inline">\(O(n \log n)\)</span>となること。C++03では特に何も制限はないが、g++ならば<span class="math inline">\(O(n \log n)\)</span>である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//昇順 (sort(vec.begin(),vec.end())) (2,1,3) -&gt; (1,2,3)</span>
sort(all(vec));
<span class="co">//降順 (ただ単純にreverseしてもいい) (2,1,3) -&gt; (3,2,1)</span>
sort(all(vec),greater&lt;<span class="dt">int</span>&gt;());</code></pre></div>
<p>第三引数には関数を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> comp(<span class="dt">const</span> <span class="dt">int</span>&amp; a ,<span class="dt">const</span> <span class="dt">int</span>&amp; b){
    <span class="kw">return</span> abs(a) &lt; abs(b);
}
<span class="dt">int</span> main(){
    vector&lt;<span class="dt">int</span>&gt; vec(<span class="dv">10</span>);
    <span class="co">//絶対値が小さい順にソート</span>
    sort(all(vec),comp);
    sort(all(vec),[](<span class="dt">int</span> l,<span class="dt">int</span> r) {<span class="kw">return</span> abs(l)&lt;abs(r)});
}</code></pre></div>
<h3 id="stable_sort"><span class="header-section-number">4.2.2</span> stable_sort</h3>
<p>sortとちがって、同じ優先順位の要素の順番は保存される。最悪計算量は<span class="math inline">\(O(n \log ^ 2 n)\)</span>である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">stable_sort(all(vec),comp);</code></pre></div>
<h2 id="unique"><span class="header-section-number">4.3</span> unique</h2>
<p>隣あう同じ要素を一つにまとめる。eraseすることに注意。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> ints[] = {<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>};
vector&lt;<span class="dt">int</span>&gt; vec(ints,ints<span class="dv">+5</span>);
vec.erase(unique(all(vec)),vec.end());
<span class="co">// 1 2 1</span>
repeat(i,vec.size()) cout &lt;&lt; vec[i] &lt;&lt; endl;</code></pre></div>
<h2 id="rotate"><span class="header-section-number">4.4</span> rotate</h2>
<p>rotateは第二引数の場所を先頭にするように回転する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>[] ints = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>};
vector&lt;<span class="dt">int</span>&gt; vec(ints,ints<span class="dv">+5</span>);
rotate(vec.begin(),vec.begin()<span class="dv">+1</span>),vec.end()); <span class="co">//2,3,4,5,1</span>
rotate(vec.begin(),vec.end()<span class="dv">-1</span>,vec.end()); <span class="co">//5,1,2,3,4</span></code></pre></div>
<h2 id="next_permutation"><span class="header-section-number">4.5</span> next_permutation</h2>
<p>順列をすべて列挙する。<span class="math inline">\(N!\)</span>個なので、それなりの勢いで大きくなる。章末の付録参照。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; V = {<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>};
<span class="co">//ソートすること。</span>
sort(all(V));

<span class="kw">do</span>{
   <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;V.size();i++){
       cout &lt;&lt; V[i] &lt;&lt; <span class="st">&quot; &quot;</span>;
   }
   cout &lt;&lt; endl;
}<span class="kw">while</span>(next_permutation(all(V)));</code></pre></div>
<h2 id="座標圧縮"><span class="header-section-number">4.6</span> 座標圧縮</h2>
<div class="sourceCode" include="cpp/zip.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iomanip&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#define rep(x,n) for(int x=0;x&lt;(n);x++)</span>
<span class="ot">#define all(vec) vec.begin(),vec.end()</span>


<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,<span class="dt">const</span> vector&lt;T&gt;&amp; vec){
    os &lt;&lt; <span class="st">&quot;[&quot;</span>;
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; v : vec){
        os &lt;&lt; v &lt;&lt; <span class="st">&quot;,&quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;]&quot;</span>;
    <span class="kw">return</span> os;
}

<span class="co">// 重なる長方形がカバーしている面積</span>
<span class="dt">int</span> main(){
    <span class="dt">int</span> k = <span class="dv">0</span>;
    <span class="kw">while</span>(<span class="kw">true</span>){
        k++;
        <span class="dt">int</span> n; cin &gt;&gt; n;
        <span class="kw">if</span>(n == <span class="dv">0</span>) <span class="kw">break</span>;
        <span class="co">// (X1,Y1) is upper left.</span>
        <span class="co">// (X1,Y1) is lower right.</span>
        vector&lt;<span class="dt">double</span>&gt; X1(n),X2(n),Y1(n),Y2(n);
        rep(i,n){
            <span class="dt">double</span> x,y,r;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;
            X1[i] = x-r;
            X2[i] = x+r;
            Y1[i] = y-r;
            Y2[i] = y+r;
        }
        <span class="co">// X,Yは全てのX座標,Y座標</span>
        vector&lt;<span class="dt">double</span>&gt; X,Y;
        X.insert(X.end(),all(X1));
        X.insert(X.end(),all(X2));
        Y.insert(Y.end(),all(Y1));
        Y.insert(Y.end(),all(Y2));

        <span class="co">// sortして重複を削除</span>
        sort(all(X));
        sort(all(Y));
        X.erase(unique(all(X)),X.end());
        Y.erase(unique(all(Y)),Y.end());

        <span class="co">// X1,X2,Y1,Y2の値をX,Y中のindexにする。この時点でintにすべきかも。</span>
        rep(i,n){
            X1[i] = lower_bound(all(X),X1[i]) - X.begin();
            X2[i] = lower_bound(all(X),X2[i]) - X.begin();
            Y1[i] = lower_bound(all(Y),Y1[i]) - Y.begin();
            Y2[i] = lower_bound(all(Y),Y2[i]) - Y.begin();
        }
        vector&lt;vector&lt;<span class="dt">char</span>&gt;&gt; is_on(X.size(),vector&lt;<span class="dt">char</span>&gt;(Y.size()));
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="kw">for</span>(<span class="dt">int</span> sx=X1[i];sx&lt;X2[i];sx++){
                <span class="kw">for</span>(<span class="dt">int</span> sy=Y1[i];sy&lt;Y2[i];sy++){
                    is_on[sx][sy] = <span class="kw">true</span>;
                }
            }
        }
        <span class="dt">double</span> ans = <span class="dv">0</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;X.size()<span class="dv">-1</span>;i++){
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;Y.size()<span class="dv">-1</span>;j++){
                <span class="kw">if</span>(is_on[i][j]){
                    ans += (X[i<span class="dv">+1</span>]-X[i]) * (Y[j<span class="dv">+1</span>]-Y[j]);
                }
            }
        }
        cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="dv">2</span>);
        cout &lt;&lt; k &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;
    }
}</code></pre></div>
<h1 id="探索"><span class="header-section-number">5</span> 探索</h1>
<h2 id="全探索"><span class="header-section-number">5.1</span> 全探索</h2>
<p>全部しらべる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> linear_search(vector&lt;<span class="dt">int</span>&gt; V,<span class="dt">int</span> val){
    repeat(i,V.size()){
        <span class="kw">if</span>(V[i] == val) <span class="kw">return</span> i;
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}</code></pre></div>
<h2 id="二分探索"><span class="header-section-number">5.2</span> 二分探索</h2>
<p>ある条件を満たす最小のものを探す。ただし単調増加な物にしかつかえない。<br />
叙述関数をPとすると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> lower = <span class="dv">0</span>,upper = <span class="dv">1000000</span>;
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">200</span>;i++){
    <span class="dt">double</span> m = (lower+upper) / <span class="dv">2</span>;
    <span class="kw">if</span>(P(m)){
        upper = m;
    }<span class="kw">else</span>{
        lower = m;
    }
    cout &lt;&lt; upper &lt;&lt; endl;
}</code></pre></div>
<p>とすると、upperに求めたい値がはいる。もしみつからなかった場合には、値は<br />
変わらない。なので、lower,upperには極端な値を設定すること。200という回数<br />
は、すこし多め。100で十分。対象がvectorの場合は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(){
    vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};
    <span class="co">// ソートする必要あり。</span>
    <span class="co">//  i  0 1 2 3 4 5 6 7 8</span>
    <span class="co">// -&gt; [1,1,1,2,2,2,3,3,3]</span>
    sort(v.begin(),v.end());
    <span class="co">// 2以上の数値が初めて現れる場所 -&gt; 3</span>
    <span class="dt">int</span> lower = lower_bound(v.begin(),v.end(),<span class="dv">2</span>) - v.begin();
    <span class="co">// 2より大きい数値が初めて表われる場所 -&gt; 6</span>
    <span class="dt">int</span> upper = upper_bound(v.begin(),v.end(),<span class="dv">2</span>) - v.begin();
    <span class="co">// 2の個数</span>
    <span class="dt">int</span> number_of_2 = upper - lower;
}</code></pre></div>
<h2 id="三分探索"><span class="header-section-number">5.3</span> 三分探索</h2>
<p>凸関数の極値を求める</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 凸関数の極大な点をもとめる</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> F,<span class="kw">typename</span> T&gt;
T ternary_search(F f,T left,T right){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">1000</span>;i++){
        T l = (<span class="dv">2</span>*left + right) / <span class="dv">3</span>;
        T r = (left + <span class="dv">2</span>*right) / <span class="dv">3</span>;
        <span class="kw">if</span>(f(l) &lt; f(r)){
            left = l;
        }<span class="kw">else</span>{
            right = r;
        }
    }
    <span class="kw">return</span> (left+right)/<span class="dv">2</span>;
}

<span class="co">// 凹関数の極小な・を求める</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> F,<span class="kw">typename</span> T&gt;
T ternary_search_concave(F f,T left,T right){
    <span class="kw">return</span> ternary_search([f](T x){<span class="kw">return</span> -f(x);},left,right);
}</code></pre></div>
<h3 id="合計の重さxを達成するような組み合わせの数え上げ"><span class="header-section-number">5.3.1</span> 合計の重さXを達成するような組み合わせの数え上げ</h3>
<div class="sourceCode" include="cpp/combi_total.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// if we have objects that each has w_{i} weight.</span>
<span class="co">//  we calc how many combination that has total weight X.</span>
<span class="co">//  O(2^(N/2) logN)?</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">int</span> howmany_combination_such_that_total_weight_is_X(vector&lt;T&gt; W,<span class="dt">int</span> X){
    <span class="co">// sort(all(W));</span>
    <span class="dt">int</span> N = W.size();
    vector&lt;vector&lt;T&gt;&gt; parts(<span class="dv">2</span>);
    copy(W.begin(),W.begin()+N/<span class="dv">2</span>,back_inserter(parts[<span class="dv">0</span>]));
    copy(W.begin()+N/<span class="dv">2</span>,W.end(),back_inserter(parts[<span class="dv">1</span>]));

    <span class="dt">int</span> ret = <span class="dv">0</span>;
    vector&lt;vector&lt;T&gt;&gt; sums(<span class="dv">2</span>,{<span class="dv">0</span>});
    <span class="kw">for</span>(size_t p=<span class="dv">0</span>;p&lt;parts.size();p++){
        <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;parts[p].size();i++){
            vector&lt;T&gt; nex;
            <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;sums[p].size();j++){
                nex.push_back(sums[p][j]);
                nex.push_back(sums[p][j]+parts[p][i]);
            }
            sums[p].swap(nex);
        }
    }
    <span class="kw">for</span>(vector&lt;T&gt;&amp; sum : sums){
        sort(sum.begin(),sum.end());
    }

    <span class="kw">for</span>(T s : sums[<span class="dv">0</span>]){
        ret += upper_bound(sums[<span class="dv">1</span>].begin(),sums[<span class="dv">1</span>].end(),X-s)
             - lower_bound(sums[<span class="dv">1</span>].begin(),sums[<span class="dv">1</span>].end(),X-s);
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="ぐるぐる"><span class="header-section-number">5.4</span> ぐるぐる</h2>
<p>いつかつかうかも。 http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189</p>
<div class="sourceCode" include="cpp/guruguru.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// WH/2,WH/2 を中心としたぐるぐる。</span>
<span class="co">// まんなかは1</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; guruguru(<span class="dt">int</span> N){
    <span class="dt">const</span> <span class="dt">int</span> WH = sqrt(N) + <span class="dv">2</span>;
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; field(WH,vector&lt;<span class="dt">int</span>&gt;(WH,N + <span class="dv">100</span>));
    {
        <span class="dt">int</span> cx=WH/<span class="dv">2</span>,cy=WH/<span class="dv">2</span>;
        field[cy][cx] = <span class="dv">1</span>;
        <span class="dt">int</span> c = <span class="dv">2</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;;i++){
            <span class="dt">int</span> sx = cx + i<span class="dv">+1</span>;
            <span class="dt">int</span> sy = cy + i;
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;<span class="dv">2</span>*i<span class="dv">+2</span>;j++){
                field[sy-j][sx] = c;
                c++;
                <span class="kw">if</span>(c &gt;= MAXN) <span class="kw">goto</span> end;
            }
            vector&lt;<span class="dt">int</span>&gt; dx = {<span class="dv">-1</span>,<span class="dv">0</span>,<span class="dv">1</span>};
            vector&lt;<span class="dt">int</span>&gt; dy = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>};
            <span class="co">// left</span>
            <span class="dt">int</span> ny = sy<span class="dv">-2</span>*i<span class="dv">-1</span>;
            <span class="dt">int</span> nx = sx;
            <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;<span class="dv">3</span>;k++){
                <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;<span class="dv">2</span>*(i<span class="dv">+1</span>);j++){
                    ny = ny + dy[k];
                    nx = nx + dx[k];
                    field[ny][nx] = c;
                    c++;
                    <span class="kw">if</span>(c &gt;= MAXN) <span class="kw">goto</span> end;
                }
            }
        }
end:;
    }
    <span class="kw">return</span> field;
}</code></pre></div>
<h1 id="文字列操作"><span class="header-section-number">6</span> 文字列操作</h1>
<p>stringをincludeする。cctypeもいるかも。</p>
<h2 id="stdstring"><span class="header-section-number">6.1</span> std::string</h2>
<p>charをラップしたテンプレートクラス。 基本的な使い方について</p>
<h3 id="部分列"><span class="header-section-number">6.1.1</span> 部分列</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">          <span class="co">//0123456789</span>
string str(<span class="st">&quot;abcdefghij&quot;</span>);
<span class="co">// 5番目以降</span>
str.substr(<span class="dv">5</span>);    <span class="co">// &quot;fghij&quot;</span>
<span class="co">// 5番目から3つ</span>
str.substr(<span class="dv">5</span>,<span class="dv">3</span>); <span class="co">// &quot;fgh&quot;</span>
<span class="co">//全部小文字にする</span>
transform(s.begin(),s.end(),s.begin(),::tolower);</code></pre></div>
<p>substrは一つの引数でそこから先全部、二つの場合は第一引数の位置から、第二<br />
引数の数だけ持ってくる。</p>
<h3 id="検索"><span class="header-section-number">6.1.2</span> 検索</h3>
<p>stringには、いくつかのfindが定義されている。線形検索なので、早い検索が必<br />
要なときには後述するKMP法やBM法を用いること。</p>
<ul>
<li><p>find 引数が最初に現れる位置</p></li>
<li><p>rfind 引数が最後に表われる位置</p></li>
<li><p>find_first_of 引数の文字のどれかが最初に表われる位置</p></li>
<li><p>find_last_of 引数の文字のどれかが最後に表われる位置</p></li>
<li><p>find_first_not_of<br />
引数の文字のどれかではない文字が最初に表われる位置</p></li>
<li><p>find_first_not_of<br />
引数の文字のどれかではない文字が最後に表われる位置</p></li>
</ul>
<p>第二引数として探すための最初の位置を指定できる。</p>
<h4 id="boyer-moore法"><span class="header-section-number">6.1.2.1</span> Boyer Moore法</h4>
<h4 id="kmp法"><span class="header-section-number">6.1.2.2</span> KMP法</h4>
<h2 id="stringstream"><span class="header-section-number">6.2</span> stringstream</h2>
<p>cinやcoutのようなstreamをstringを元に作成したりする。基本的には、string<br />
をフォーマットしたり、intやlongに、intやlongから変換するために使用する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">stringstream ss;
ss &lt;&lt; <span class="dv">102</span>;
string s;
ss &gt;&gt; s;</code></pre></div>
<h2 id="再帰下降構文解析"><span class="header-section-number">6.3</span> 再帰下降構文解析</h2>
<p>BNFを書いて、それにしたがっていく。左再帰除去を忘れずに。</p>
<div class="sourceCode" include="cpp/parse.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;cctype&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> string::const_iterator Cursor;
<span class="kw">class</span> ParseError{};

<span class="co">// &lt;四則演算の式&gt; ::= &lt;乗算除算の式&gt; (+ or -) &lt;乗算除算の式&gt; (+ or -) ...</span>
<span class="co">// &lt;乗算除算の式&gt; ::= &lt;括弧か数&gt; (* or /) &lt;括弧か数&gt; (* or /) ...</span>
<span class="co">// &lt;括弧か数&gt;     ::= &#39;(&#39; &lt;四則演算の式&gt; &#39;)&#39; or &lt;数&gt;</span>
<span class="co">// &lt;数&gt;           ::= (0|1|2|3|4|5|6|7|8|9)+</span>

<span class="dt">int</span> expression(Cursor&amp;);
<span class="dt">int</span> term(Cursor&amp;);
<span class="dt">int</span> factor(Cursor&amp;);
<span class="dt">int</span> number(Cursor&amp;);

<span class="co">// &lt;四則演算の式&gt; ::= &lt;乗算除算の式&gt; (+ or -) &lt;乗算除算の式&gt; (+ or -) ...</span>
<span class="dt">int</span> expression(Cursor &amp;c){
    <span class="dt">int</span> ret = term(c);
    <span class="kw">while</span>(*c == <span class="st">&#39;+&#39;</span> <span class="kw">or</span> *c == <span class="st">&#39;-&#39;</span>){
        <span class="kw">if</span>(*c == <span class="st">&#39;+&#39;</span>){
            c++;
            ret += term(c);
        }<span class="kw">else</span>{
            c++;
            ret -= term(c);
        }
    }
    <span class="kw">return</span> ret;
}

<span class="co">// &lt;乗算除算の式&gt; ::= &lt;括弧か数&gt; (* or /) &lt;括弧か数&gt; (* or /) ...</span>
<span class="dt">int</span> term(Cursor &amp;c){
    <span class="dt">int</span> ret = factor(c);
    <span class="kw">while</span>(*c == <span class="st">&#39;*&#39;</span> <span class="kw">or</span> *c == <span class="st">&#39;/&#39;</span>){
        <span class="kw">if</span>(*c == <span class="st">&#39;*&#39;</span>){
            c++;
            ret *= factor(c);
        }<span class="kw">else</span>{
            c++;
            ret /= factor(c);
        }
    }
    <span class="kw">return</span> ret;
}

<span class="co">// &lt;括弧か数&gt;     ::= &#39;(&#39; &lt;四則演算の式&gt; &#39;)&#39; or &lt;数&gt;</span>
<span class="dt">int</span> factor(Cursor &amp;c){
    <span class="kw">if</span>(*c == <span class="st">&#39;(&#39;</span>){
        c++;
        <span class="dt">int</span> ret = expression(c);
        c++; <span class="co">// &#39;)&#39;</span>
        <span class="kw">return</span> ret;
    }<span class="kw">else</span>{
        <span class="kw">return</span> number(c);
    }
}

<span class="co">// &lt;数&gt;           ::= (0|1|2|3|4|5|6|7|8|9)+</span>
<span class="dt">int</span> number(Cursor &amp;c){
    stringstream ss;
    <span class="kw">while</span>(isdigit(*c)){
        ss &lt;&lt; *c;
        c++;
    }
    <span class="dt">int</span> ret;
    ss &gt;&gt; ret;
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> test_case;
    cin &gt;&gt; test_case;
    cin.ignore();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;test_case;i++){
        string s;
        getline(cin,s);
        Cursor c = s.begin();
        cout &lt;&lt; expression(c) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="ll1文法--再帰下降で書けるかどうか"><span class="header-section-number">6.4</span> LL1文法(&lt;-&gt; 再帰下降で書けるかどうか)</h2>
<p>予測型構文解析表を埋めて重複をチュックする。テストしたい。<br />
一般に、&quot;X -&gt; Xb,X -&gt; a&quot;なる生成規則は、&quot;X-&gt;aX',X'-&gt;bX',X'-&gt;&quot;とできる。<br />
これは前者がab*なる形の文字列を導出するからである。</p>
<div class="sourceCode" include="cpp/check_ll1.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;map&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> Rule{
    <span class="dt">char</span> from;
    vector&lt;<span class="dt">char</span>&gt; to;
    Rule(<span class="dt">char</span> from_,vector&lt;<span class="dt">char</span>&gt; to_)
        : from(from_),to(to_){
    }
};

<span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> Rule&amp; lhs, <span class="dt">const</span> Rule&amp; rhs){
    <span class="kw">if</span>(lhs.from != rhs.from <span class="kw">or</span> lhs.to.size() != rhs.to.size()){
        <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;lhs.to.size();i++){
        <span class="kw">if</span>(lhs.to[i] != rhs.to[i]){
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Rule&amp; lhs, <span class="dt">const</span> Rule&amp; rhs){
    <span class="kw">if</span>(lhs.from != rhs.from){
        <span class="kw">return</span> lhs.from &lt; rhs.from;
    }
    <span class="kw">if</span>(lhs.to.size() != rhs.to.size()){
        <span class="kw">return</span> lhs.to.size() &lt; rhs.to.size();
    }
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;lhs.to.size();i++){
        <span class="kw">if</span>(lhs.to[i] != rhs.to[i]){
            <span class="kw">return</span> lhs.to[i] &lt; rhs.to[i];
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="dt">const</span> Rule&amp; lhs, <span class="dt">const</span> Rule&amp; rhs){
    <span class="kw">return</span> <span class="kw">not</span>(lhs == rhs) <span class="kw">and</span> <span class="kw">not</span>(lhs &lt; rhs);
}

ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,Rule r){
    os &lt;&lt; r.from &lt;&lt; <span class="st">&quot;-&gt;&quot;</span>;
    <span class="kw">for</span>(<span class="dt">char</span> c : r.to){
        os &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; c;
    }
    <span class="kw">return</span> os;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,set&lt;T&gt; s){
    os &lt;&lt; <span class="st">&quot;{&quot;</span>;
    <span class="kw">for</span>(T v : s){
        os &lt;&lt; v &lt;&lt; <span class="st">&quot;,&quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;}&quot;</span>;
    <span class="kw">return</span> os;
}

<span class="co">// can be written in recursive descent parsing?</span>
<span class="co">//  see tiger book(p.46).</span>
<span class="dt">bool</span> can_be_written_in_recursive_descent_parsing(<span class="dt">const</span> set&lt;<span class="dt">char</span>&gt;&amp; terminal,
                                                 <span class="dt">const</span> set&lt;<span class="dt">char</span>&gt;&amp; non_terminal,
                                                 <span class="dt">const</span> vector&lt;Rule&gt;&amp; rules){
    <span class="kw">for</span>(Rule r : rules){
        cerr &lt;&lt; r &lt;&lt; endl;
    }
    map&lt;<span class="dt">char</span>,<span class="dt">bool</span>&gt; nullable;
    map&lt;<span class="dt">char</span>,set&lt;<span class="dt">char</span>&gt;&gt; first,follow;
    <span class="kw">for</span>(<span class="dt">char</span> c : non_terminal){
        nullable[c] = <span class="kw">false</span>;
        first[c] = {};
        follow[c] = {};
    }
    <span class="kw">for</span>(<span class="dt">char</span> c : terminal){
        nullable[c] = <span class="kw">false</span>;
        first[c] = {c};
        follow = {};
    }

    {
        <span class="dt">bool</span> changed;
        <span class="kw">do</span>{
            changed = <span class="kw">false</span>;
            <span class="kw">for</span>(Rule r : rules){
                <span class="dt">bool</span> all_nullable = <span class="kw">true</span>;
                <span class="kw">for</span>(<span class="dt">char</span> t : r.to){
                    all_nullable = all_nullable <span class="kw">and</span> nullable[t];
                }
                <span class="kw">if</span>(all_nullable <span class="kw">and</span> <span class="kw">not</span> nullable[r.from]){
                    nullable[r.from] = <span class="kw">true</span>;
                    changed = <span class="kw">true</span>;
                }
                <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;r.to.size();i++){
                    <span class="dt">bool</span> nul = <span class="kw">true</span>;
                    <span class="kw">for</span>(size_t k=<span class="dv">0</span>;k&lt;i;k++){
                        nul = nul <span class="kw">and</span> nullable[r.to[k]];
                    }
                    <span class="kw">if</span>(nul){
                        size_t bef = first[r.from].size();
                        first[r.from].insert(first[r.to[i]].begin(),
                                             first[r.to[i]].end());
                        changed = changed <span class="kw">or</span> (bef != first[r.from].size());
                    }
                }
                <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;r.to.size();i++){
                    <span class="co">// nullable[y[k]] for k &lt;- [i+1,]</span>
                    <span class="dt">bool</span> nul = <span class="kw">true</span>;
                    <span class="kw">for</span>(<span class="dt">int</span> k=i<span class="dv">+1</span>;k&lt;(<span class="dt">int</span>)r.to.size();k++){
                        nul = nul <span class="kw">and</span> nullable[r.to[k]];
                    }
                    <span class="kw">if</span>(nul){
                        size_t bef = follow[r.to[i]].size();
                        follow[r.to[i]].insert(follow[r.from].begin(),
                                               follow[r.from].end());
                        changed = changed <span class="kw">or</span> (bef != follow[r.to[i]].size());
                    }
                }
                <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;r.to.size();i++){
                    <span class="kw">for</span>(size_t j=i<span class="dv">+1</span>;j&lt;r.to.size();j++){
                        <span class="co">// nullable[y[k]] for k &lt;- [i+1,j-1]</span>
                        <span class="dt">bool</span> nul = <span class="kw">true</span>;
                        <span class="kw">for</span>(size_t k=i<span class="dv">+1</span>;k&lt;j;k++){
                            nul = nul <span class="kw">and</span> nullable[r.to[k]];
                        }
                        <span class="kw">if</span>(nul){
                            size_t bef = follow[r.to[i]].size();
                            follow[r.to[i]].insert(first[r.to[j]].begin(),
                                                   first[r.to[j]].end());
                            changed = changed <span class="kw">or</span> (bef != follow[r.to[i]].size());
                        }
                    }
                }
            }
        }<span class="kw">while</span>(changed);
    }
    <span class="kw">for</span>(<span class="dt">char</span> c : non_terminal){
        cerr &lt;&lt; c &lt;&lt; endl
             &lt;&lt; <span class="st">&quot;nullable? &quot;</span> &lt;&lt; nullable[c] &lt;&lt; endl
             &lt;&lt; <span class="st">&quot;first &quot;</span> &lt;&lt; first[c] &lt;&lt; endl
             &lt;&lt; <span class="st">&quot;follow &quot;</span> &lt;&lt; follow[c] &lt;&lt; endl;
    }
    map&lt;<span class="dt">char</span>,map&lt;<span class="dt">char</span>,set&lt;Rule&gt;&gt;&gt; maps;
    <span class="kw">for</span>(Rule r : rules){
        <span class="co">// check r.to is nullable or not.</span>
        <span class="co">//  and collect first.</span>
        set&lt;<span class="dt">char</span>&gt; to_first;
        <span class="dt">bool</span> to_nullable = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">char</span> t : r.to){
            to_first.insert(first[t].begin(),first[t].end());
            to_nullable = to_nullable <span class="kw">and</span> nullable[t];
            <span class="kw">if</span>(<span class="kw">not</span> to_nullable) <span class="kw">break</span>;
        }

        <span class="kw">for</span>(<span class="dt">char</span> tf : to_first){
            maps[r.from][tf].insert(r);
        }
        <span class="kw">if</span>(to_nullable){
            <span class="kw">for</span>(<span class="dt">char</span> t : follow[r.from]){
                maps[r.from][t].insert(r);
            }
        }
    }

    cerr &lt;&lt; <span class="st">&quot;Map&quot;</span> &lt;&lt; endl;
    <span class="dt">bool</span> dup = <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">const</span> pair&lt;<span class="dt">char</span>,map&lt;<span class="dt">char</span>,set&lt;Rule&gt;&gt;&gt; m : maps){
        <span class="dt">int</span> from = m.first;
        <span class="kw">for</span>(<span class="dt">const</span> pair&lt;<span class="dt">char</span>,set&lt;Rule&gt;&gt; p : m.second){
            <span class="dt">int</span> to = p.first;
            cerr &lt;&lt; <span class="dt">char</span>(from) &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; <span class="dt">char</span>(to) &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;
            dup = dup <span class="kw">or</span> p.second.size() &gt; <span class="dv">1</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">not</span> dup;
}


<span class="dt">int</span> main(){
    set&lt;<span class="dt">char</span>&gt; terminal;
    set&lt;<span class="dt">char</span>&gt; non_terminal;

    {
        <span class="co">// terminal;</span>
        <span class="dt">int</span> n;cin &gt;&gt; n;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="dt">char</span> c;cin &gt;&gt; c;
            terminal.insert(c);
        }
    }

    {
        <span class="co">// non_terminal;</span>
        <span class="dt">int</span> n;cin &gt;&gt; n;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="dt">char</span> c;cin &gt;&gt; c;
            non_terminal.insert(c);
        }
    }

    <span class="co">// number of rule.</span>
    <span class="dt">int</span> n;
    cin &gt;&gt; n;
    vector&lt;Rule&gt; rules;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="dt">int</span> k;cin &gt;&gt; k;
        <span class="dt">char</span> from;cin &gt;&gt; from;
        vector&lt;<span class="dt">char</span>&gt; to(k);
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;k;j++){
            cin &gt;&gt; to[j];
        }
        rules.push_back(Rule(from,to));
    }
    cout &lt;&lt; can_be_written_in_recursive_descent_parsing(terminal,non_terminal,rules) &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}

              <span class="co">// 9                  // 9</span>
<span class="co">// 3          // $ + - * / i n ( )  // $ + - * / i n ( )</span>
<span class="co">// a c d      // 3                  // 6</span>
<span class="co">// 3          // S E T              // S E T D U F</span>
<span class="co">// X Y Z      // 10                 // 12</span>
<span class="co">// 6          // 2 S E $            // 2 S E $</span>
<span class="co">// 1 X Y      // 3 E E p T          // 2 E T D</span>
<span class="co">// 1 X a      // 3 E E m T          // 3 D + T D</span>
<span class="co">// 0 Y        // 1 E T              // 3 D - T D</span>
<span class="co">// 1 Y c      // 3 T T * F          // 0 D</span>
<span class="co">// 1 Z d      // 3 T T / F          // 2 T F U</span>
<span class="co">// 3 Z X Y Z  // 1 T F              // 3 U * F U</span>
<span class="co">//  -&gt; 0      // 1 F i              // 3 U / F U</span>
              <span class="co">// 1 F n              // 0 U</span>
              <span class="co">// 3 F ( E )          // 1 F i</span>
              <span class="co">//  -&gt; 0              // 1 F n</span>
                                    <span class="co">// 3 F ( E )</span>
                                    <span class="co">//  -&gt; 1</span></code></pre></div>
<h1 id="整数論"><span class="header-section-number">7</span> 整数論</h1>
<h2 id="最大公約数最小公倍数"><span class="header-section-number">7.1</span> 最大公約数,最小公倍数</h2>
<p>ユークリッドの互除法を使う。intをlong longに置換してもいい。 <span class="math inline">\(O(\log n)\)</span></p>
<h3 id="最大公約数"><span class="header-section-number">7.1.1</span> 最大公約数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> gcd(<span class="dt">int</span> a,<span class="dt">int</span> b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}</code></pre></div>
<h3 id="最小公倍数"><span class="header-section-number">7.1.2</span> 最小公倍数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lcm(<span class="dt">int</span> a,<span class="dt">int</span> b){
    <span class="kw">return</span> a*b / gcd(a,b);
}</code></pre></div>
<h2 id="mod"><span class="header-section-number">7.2</span> mod</h2>
<p>long longに入らないような答えのときにmodが登場する。</p>
<h3 id="modの計算式について"><span class="header-section-number">7.2.1</span> modの計算式について</h3>
<p><span class="math display">\[\begin{aligned}
a \equiv c &amp; \pmod m \\
b \equiv d &amp; \pmod m\end{aligned}\]</span></p>
<p>の条件下では以下の式が成り立つ。</p>
<p><span class="math display">\[\begin{aligned}
a+b \equiv c+d  &amp; \pmod m \\
a-b \equiv c-d  &amp; \pmod m \\
a \times b \equiv c \times d  &amp; \pmod m\end{aligned}\]</span></p>
<p>さらに、mが素数の場合、以下の関係が成り立つ。</p>
<p><span class="math display">\[\begin{aligned}
a ^ m \equiv a \pmod m \\
a ^ {m-1} \equiv 1 \pmod m \\
a ^ {m-2} \equiv \frac{1}{a} \pmod m\end{aligned}\]</span></p>
<p>つまり、<span class="math inline">\(a\)</span>で割ることと、<span class="math inline">\(a^{m-2}\)</span>を掛けることは同じである。<br />
これは、<span class="math inline">\(C(10000,5000) \pmod p\)</span>といった式を計算する際、次の冪乗の演算と組みあわせて用いる。</p>
<h3 id="冪乗のmod"><span class="header-section-number">7.2.2</span> 冪乗のmod</h3>
<p>いわゆるmod_pow。計算量は<span class="math inline">\(O(\log n)\)</span>。</p>
<div class="sourceCode" include="cpp/mod_pow.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T,<span class="kw">typename</span> F&gt;
T apply_doubling(<span class="dt">const</span> T&amp; x,
                 <span class="dt">const</span> <span class="dt">long</span> <span class="dt">long</span>&amp; n,
                 <span class="dt">const</span> T&amp; id_elem,
                 <span class="dt">const</span> F&amp; binary_op){
    <span class="kw">if</span>(n == <span class="dv">0</span>) <span class="kw">return</span> id_elem;
    T ret = apply_doubling(binary_op(x,x),n/<span class="dv">2</span>,id_elem,binary_op);
    <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">1</span>) ret = binary_op(ret,x);
    <span class="kw">return</span> ret;
}

<span class="dt">long</span> <span class="dt">long</span> mod_pow(<span class="dt">long</span> <span class="dt">long</span> x,<span class="dt">long</span> <span class="dt">long</span> n,<span class="dt">long</span> <span class="dt">long</span> mod){
    <span class="kw">return</span> apply_doubling(x,n,<span class="dv">1ll</span>,[mod](ll a,ll b){<span class="kw">return</span> a*b%mod;});
}</code></pre></div>
<p>ちなみにC++のpowを使うときに、引数が整数で、返り値も整数であることを期待<br />
するときには、上記のpowを使うべき。なぜならC++のpowは<br />
double,double-&gt;doubleな関数であるから。</p>
<h2 id="素数"><span class="header-section-number">7.3</span> 素数</h2>
<h3 id="エラトステネスの篩"><span class="header-section-number">7.3.1</span> エラトステネスの篩</h3>
<div class="sourceCode" include="cpp/sieve.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">//上限より余裕を取ること。</span>
vector&lt;<span class="dt">bool</span>&gt; sieve(<span class="dt">const</span> <span class="dt">int</span> M){
    vector&lt;<span class="dt">bool</span>&gt; isPrime(M);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++) isPrime[i] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i&lt;M;i++){
        <span class="kw">if</span>(<span class="kw">not</span> isPrime[i]) <span class="kw">continue</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=i*i;j&lt;M;j+=i){
            isPrime[j] = <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> isPrime;
}

<span class="co">// リストがほしいときはこっち</span>
vector&lt;<span class="dt">int</span>&gt; sieve(<span class="dt">const</span> <span class="dt">int</span> M){
    vector&lt;<span class="dt">bool</span>&gt; isPrime(M);
    vector&lt;<span class="dt">int</span>&gt; primes;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++) isPrime[i] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i&lt;M;i++){
        <span class="kw">if</span>(<span class="kw">not</span> isPrime[i]) <span class="kw">continue</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=i*i;j&lt;M;j+=i){
            isPrime[j] = <span class="kw">false</span>;
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++){
        <span class="kw">if</span>(isPrime[i]) primes.push_back(i);
    }
    <span class="kw">return</span> primes;
}</code></pre></div>
<div class="sourceCode" include="python/sieve.py"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">from</span> math <span class="im">import</span> <span class="op">*</span>

<span class="kw">def</span> sieve(N):
    primes <span class="op">=</span> <span class="bu">set</span>()
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>,N):
        primes.add(i)

    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>,ceil(sqrt(N))):
        <span class="cf">if</span> i <span class="op">in</span> primes:
            <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(i<span class="op">*</span>i,N,i):
                primes.discard(j)

    <span class="cf">return</span> primes</code></pre></div>
<p>素数のリストが欲しかったら、適当に突っ込むこと。<br />
実際には<span class="math inline">\(O(n \log \log n)\)</span>だけれど、大体<span class="math inline">\(O(n)\)</span>だと思っていい。</p>
<h3 id="素因数分解"><span class="header-section-number">7.3.2</span> 素因数分解</h3>
<div class="sourceCode" include="cpp/prime_decomposition.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// primes is primes under sqrt(N).</span>
vector&lt;<span class="dt">int</span>&gt; prime_decomposition(<span class="dt">int</span> N,<span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt;&amp; primes){
    vector&lt;<span class="dt">int</span>&gt; ret;
    <span class="kw">for</span>(<span class="dt">int</span> p : primes){
        <span class="kw">while</span>(N % p == <span class="dv">0</span>){
            N /= p;
            ret.push_back(p);
        }
    }
    <span class="kw">if</span>(N != <span class="dv">1</span>) ret.push_back(N);
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="コンビネーション"><span class="header-section-number">7.4</span> コンビネーション</h2>
<p>くみあわせ。</p>
<div class="sourceCode" include="cpp/combi.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="co">//いい感じのやつ (n=61まで大丈夫)</span>
<span class="co">//  modにしても良い。O(N)</span>
ll nCr(<span class="dt">int</span> n,<span class="dt">int</span> r){
    <span class="kw">if</span>(n &lt; r) <span class="kw">return</span> <span class="dv">0</span>;
    r = min(r,n-r);
    ll ret = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;r;i++){
        ret *= n-i;
        ret /= i<span class="dv">+1</span>;
    }
    <span class="kw">return</span> ret;
}


ll mod_pow(ll x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    ll ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span> == <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}
ll nCr_mod(ll n,ll r,ll mod){
    <span class="kw">if</span>(n &lt; r) <span class="kw">return</span> <span class="dv">0</span>;
    r = min(r,n-r);
    ll ret = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;r;i++){
        ret = (ret * (n-i)) % mod;
        <span class="co">// ret /= i+1;</span>
        ret = (ret * mod_pow(i<span class="dv">+1</span>,mod<span class="dv">-2</span>,mod)) % mod;
    }
    <span class="kw">return</span> ret;
}

<span class="co">// http://www.ravco.jp/cat/view.php?cat_id=6179</span>
<span class="co">// 区別するn 個のものから，繰り返し用いることを許して，r 個取り出して作った組</span>
<span class="co">// &lt;-&gt; 区別しないr 個のボールを，区別するn 個の箱に配る場合の総数</span>
ll nHr(ll n,ll r){
    <span class="kw">return</span> nCr(r+n<span class="dv">-1</span>,r);
}

ll nHr_mod(ll n,ll r,ll mod){
    <span class="kw">return</span> nCr_mod(r+n<span class="dv">-1</span>,r,mod);
}

<span class="co">//パスカルの三角形 (n=66まで大丈夫)</span>
<span class="co">//たくさん必要になるときはこっちのほうがいい。</span>
ll combi_tri(<span class="dt">int</span> n,<span class="dt">int</span> r){
    <span class="dt">int</span> N = n<span class="dv">+1</span>;
    vector&lt;vector&lt;ll&gt; &gt; memo(N,vector&lt;ll&gt;(N,<span class="dv">0</span>));
    memo[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;N;i++){
        memo[i][<span class="dv">0</span>] = memo[i<span class="dv">-1</span>][<span class="dv">0</span>];
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;j&lt;N;j++){
            memo[i][j] = memo[i<span class="dv">-1</span>][j<span class="dv">-1</span>] + memo[i<span class="dv">-1</span>][j];
        }
    }
    <span class="kw">return</span> memo[n][r];
}

<span class="co">// testing...</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> BidirectionalIterator&gt;
<span class="dt">bool</span> next_combination(BidirectionalIterator first1,
                      BidirectionalIterator last1,
                      BidirectionalIterator first2,
                      BidirectionalIterator last2){
    <span class="kw">if</span>((first1 == last1) <span class="kw">or</span> (first2 == last2)){
        <span class="kw">return</span> <span class="kw">false</span>;
    }
    BidirectionalIterator m1 = last1;
    BidirectionalIterator m2 = last2;
    --m2;
    <span class="kw">while</span>(--m1 != first1 &amp;&amp; <span class="kw">not</span> (*m1 &lt; *m2)){
    }
    <span class="dt">bool</span> result = (m1 == first1) <span class="kw">and</span> <span class="kw">not</span> (*first1 &lt; *m2);
    <span class="kw">if</span>(<span class="kw">not</span> result){
        <span class="kw">while</span>(first2 != m2 <span class="kw">and</span> <span class="kw">not</span>(*m1 &lt; *first2)){
            ++first2;
        }
        first1 = m1;
        iter_swap(first1,first2);
        ++first1;++first2;
    }
    <span class="kw">if</span>((first1 != last1) <span class="kw">and</span> (first2 != last2)){
        m1 = last1; m2 = first2;
        <span class="kw">while</span>((m1 != first1) <span class="kw">and</span> (m2 != last2)){
            iter_swap(--m1,m2);
            ++m2;
        }
        reverse(first1,m1);
        reverse(first1,last1);
        reverse(m2,last2);
        reverse(first2,last2);
    }
    <span class="kw">return</span> <span class="kw">not</span> result;
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> BidirectionalIterator&gt;
<span class="dt">bool</span> next_combination(BidirectionalIterator first,
                      BidirectionalIterator middle,
                      BidirectionalIterator last){
    <span class="kw">return</span> next_combination(first,middle,middle,last);
}

<span class="kw">template</span>&lt;<span class="kw">class</span> BidirectionalIterator&gt;
<span class="kw">inline</span> <span class="dt">bool</span> prev_combination(BidirectionalIterator first,
                             BidirectionalIterator middle,
                             BidirectionalIterator last){
  <span class="kw">return</span> next_combination(middle,last,first,middle);
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,<span class="dt">const</span> vector&lt;T&gt;&amp; vec){
    os &lt;&lt; <span class="st">&quot;[&quot;</span>;
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; v : vec){
        os &lt;&lt; v &lt;&lt; <span class="st">&quot;,&quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;]&quot;</span>;
    <span class="kw">return</span> os;
}

<span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> ull;

<span class="dt">void</span> print_bit(ull S, <span class="dt">int</span> n=<span class="dv">64</span>){
    <span class="kw">for</span>(<span class="dt">int</span> i=n<span class="dv">-1</span>; i&gt;=<span class="dv">0</span>; i--){
        <span class="kw">if</span>(S&gt;&gt;i &amp; <span class="dv">1</span>) std::cout &lt;&lt; <span class="dv">1</span>;
        <span class="kw">else</span> std::cout &lt;&lt; <span class="dv">0</span>;
    }
    std::cout &lt;&lt; std::endl;
}

<span class="dt">void</span> subset_combination(<span class="dt">int</span> n, <span class="dt">int</span> k){
    ull S = (<span class="dv">1ULL</span> &lt;&lt; k) - <span class="dv">1ULL</span>;
    ull E = ~((<span class="dv">1ULL</span> &lt;&lt; n) - <span class="dv">1ULL</span>);
    <span class="kw">while</span>(!(S &amp; E)){
        print_bit(S, n);
        ull smallest = S &amp; -S;
        ull ripple = S + smallest;
        ull nsmallest = ripple &amp; -ripple;
        S = ripple | (((nsmallest / smallest) &gt;&gt; <span class="dv">1</span>) - <span class="dv">1</span>);
    }
}


<span class="dt">int</span> main(){
    <span class="co">// poyoから2つえらぶ</span>
    vector&lt;<span class="dt">int</span>&gt; poyo = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>};
    <span class="dt">int</span> N = poyo.size(),R = <span class="dv">3</span>;
    <span class="kw">do</span>{
        vector&lt;<span class="dt">int</span>&gt; c(poyo.begin(),poyo.begin()+R);
        cerr &lt;&lt; c  &lt;&lt; endl;
    }<span class="kw">while</span>(next_combination(poyo.begin(),poyo.begin()+R,poyo.end()));

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="確率的なアレ"><span class="header-section-number">7.5</span> 確率的なアレ</h2>
<p>テスト中。</p>
<div class="sourceCode" include="cpp/pollard_rho.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n&lt; 341550071728321 , ok.</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;

<span class="co">// will not overflow even if mod mod is too big..</span>
ll mod_mul(ll a,ll b,ll mod){
    <span class="kw">if</span>(b == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    ll res = mod_mul((a+a)%mod,b/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(b % <span class="dv">2</span> == <span class="dv">1</span>) res = (res + a)%mod;
    <span class="kw">return</span> res;
}

<span class="co">// use mod_mul if mod is too big.</span>
ll mod_pow(ll x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>) <span class="kw">return</span> <span class="dv">1</span>;
    ll ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span>== <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}

<span class="co">// return probably prime.</span>
<span class="co">//  if n &lt; 341550071728321 return correct answer.</span>
<span class="dt">bool</span> miller_rabin(ll n){
    <span class="kw">if</span>(n == <span class="dv">2</span>) <span class="kw">return</span> <span class="kw">true</span>;
    <span class="kw">if</span>(n % <span class="dv">2</span> == <span class="dv">0</span> <span class="kw">or</span> n &lt;= <span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>;
    ll s=<span class="dv">0</span>,d=n<span class="dv">-1</span>;
    <span class="dt">static</span> <span class="dt">const</span> ll a[] = {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,n<span class="dv">+1</span>};

    <span class="kw">while</span>(d % <span class="dv">2</span> == <span class="dv">0</span>){
        s++;d/=<span class="dv">2</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;a[i]&lt;n;i++){
        ll x = mod_pow(a[i],d,n);
        <span class="kw">if</span>(x != <span class="dv">1</span>){
            ll r;
            <span class="kw">for</span>(r=<span class="dv">0</span>;r&lt;s;r++){
                <span class="kw">if</span>(x == n<span class="dv">-1</span>) <span class="kw">break</span>;
                x = mod_mul(x,x,n);
            }
            <span class="kw">if</span>(r == s) <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

ll gcd(ll a,ll b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}

<span class="kw">inline</span> ll random(ll x,ll c,ll m){
    <span class="kw">return</span> (mod_mul(x,x,m)+c)%m;
}

vector&lt;<span class="dt">bool</span>&gt; sieve(<span class="dt">const</span> <span class="dt">int</span> M){
    vector&lt;<span class="dt">bool</span>&gt; isPrime(M);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;M;i++) isPrime[i] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i*i &lt; M;i++){
        <span class="kw">if</span>(<span class="kw">not</span> isPrime[i]) <span class="kw">continue</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=i*i;j&lt;M;j+=i){
            isPrime[j] = <span class="kw">false</span>;
        }
    }
    <span class="kw">return</span> isPrime;
}

<span class="co">// primes must contatin 2.</span>
vector&lt;ll&gt; pollard_rho(ll n,<span class="dt">const</span> vector&lt;ll&gt;&amp; primes,<span class="dt">bool</span> precheck=<span class="kw">true</span>){
    <span class="kw">if</span>(n == <span class="dv">0</span> <span class="kw">or</span> n == <span class="dv">1</span>) <span class="kw">return</span> vector&lt;ll&gt;(<span class="dv">1</span>,n);
    vector&lt;ll&gt; ret;
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> constants[] = {<span class="dv">1</span>,<span class="dv">51</span>,<span class="dv">73</span>,<span class="dv">0</span>};
    <span class="kw">if</span>(precheck){
        <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;primes.size();i++){
            <span class="kw">while</span>(n % primes[i] == <span class="dv">0</span>){
                n /= primes[i];
                ret.push_back(primes[i]);
            }
            <span class="kw">if</span>(n == <span class="dv">1</span>) <span class="kw">return</span> ret;
        }
    }
    <span class="kw">if</span>(miller_rabin(n)){
        ret.push_back(n);
        <span class="kw">return</span> ret;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;constants[i];i++){
        ll x = <span class="dv">2</span>,y = <span class="dv">2</span>,d = <span class="dv">1</span>;
        <span class="kw">while</span>(d == <span class="dv">1</span>){
            x = random(x,constants[i],n);
            y = random(random(y,constants[i],n),constants[i],n);
            d = gcd(abs(x-y),n);
        }
        <span class="kw">if</span>(d == n) <span class="kw">continue</span>;

        vector&lt;ll&gt; dp = pollard_rho(d,primes,<span class="kw">false</span>);
        vector&lt;ll&gt; ndp = pollard_rho(n/d,primes,<span class="kw">false</span>);
        <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;dp.size();j++){
            ret.push_back(dp[j]);
        }
        <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;ndp.size();j++){
            ret.push_back(ndp[j]);
        }
        <span class="kw">return</span> ret;
    }
    <span class="kw">return</span> ret;
}


<span class="dt">int</span> main(){
    <span class="dt">int</span> N = <span class="dv">100</span>;
    vector&lt;<span class="dt">bool</span>&gt; isprime = sieve(<span class="dv">5</span>);
    vector&lt;ll&gt; primes;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;isprime.size();i++){
        <span class="kw">if</span>(isprime[i]){
            primes.push_back(i);
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
        <span class="co">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; miller_rabin(i) &lt;&lt; &quot; &quot; &lt;&lt; endl;</span>
        vector&lt;ll&gt; ps = pollard_rho(i,primes,<span class="kw">true</span>);
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;ps.size();j++){
            cout &lt;&lt; ps[j] &lt;&lt; <span class="st">&quot; &quot;</span>;
        }
        cout &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="乱数"><span class="header-section-number">7.6</span> 乱数</h2>
<p>XORShiftをつかったらうれしいかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">long</span> xor128(){
    <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">long</span> x=<span class="dv">123456789</span>,y=<span class="dv">362436069</span>,z=<span class="dv">521288629</span>,w=<span class="dv">88675123</span>;
    <span class="dt">unsigned</span> <span class="dt">long</span> t;
    t=(x^(x&lt;&lt;<span class="dv">11</span>));x=y;y=z;z=w; <span class="kw">return</span>( w=(w^(w&gt;&gt;<span class="dv">19</span>))^(t^(t&gt;&gt;<span class="dv">8</span>)) );
}</code></pre></div>
<h2 id="基数変換"><span class="header-section-number">7.7</span> 基数変換</h2>
<div class="sourceCode" include="cpp/digit_conv.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; int_to_digits(<span class="dt">int</span> base,<span class="dt">int</span> N){
    vector&lt;<span class="dt">int</span>&gt; rev_ret;
    <span class="kw">while</span>(N != <span class="dv">0</span>){
        rev_ret.push_back(N % base);
        N /= base;
    }
    reverse(all(rev_ret));
    <span class="kw">return</span> rev_ret;
}

<span class="dt">int</span> digits_to_int(<span class="dt">int</span> base,<span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt;&amp; digits){
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dt">int</span>)digits.size();i++){
        ret *= base;
        ret += digits[i];
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="二次方程式"><span class="header-section-number">7.8</span> 二次方程式</h2>
<div class="sourceCode" include="cpp/solve_quadratic_equation.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// solve ax^2 + bx + c = 0.</span>
vector&lt;<span class="dt">double</span>&gt; solve_quadratic_equation(<span class="dt">double</span> a,<span class="dt">double</span> b,<span class="dt">double</span> c){
    vector&lt;<span class="dt">double</span>&gt; ret;
    <span class="kw">if</span>(abs(a-EPS) &lt; <span class="dv">0</span>){
        ret.push_back(-c/b);
    }<span class="kw">else</span>{
        <span class="dt">double</span> d = b*b<span class="dv">-4</span>*a*c;
        <span class="kw">if</span>(d &gt;= <span class="dv">0</span>){
            <span class="kw">if</span>(b &gt;= <span class="dv">0</span>){
                ret.push_back(<span class="dv">-2</span>*c/(b+sqrt(d)));
                ret.push_back((-b-sqrt(d))/(<span class="dv">2</span>*a));
            }<span class="kw">else</span>{
                ret.push_back(<span class="dv">-2</span>*c/(b-sqrt(d)));
                ret.push_back((-b+sqrt(d))/(<span class="dv">2</span>*a));
            }
            <span class="kw">if</span>(abs(ret[<span class="dv">0</span>]-ret[<span class="dv">1</span>]) &lt; EPS){
                ret.pop_back();
            }
        }
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="連立方程式"><span class="header-section-number">7.9</span> 連立方程式</h2>
<p>テスト中</p>
<div class="sourceCode" include="cpp/gauss_jordan.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> none = <span class="dv">0</span>; <span class="co">// if no answer</span>
<span class="dt">const</span> <span class="dt">int</span> one = <span class="dv">1</span>;  <span class="co">// if there is exactly one answer</span>
<span class="dt">const</span> <span class="dt">int</span> many = <span class="dv">2</span>; <span class="co">// many answer.</span>
<span class="co">// answer will be inserted in b.</span>
<span class="co">//  test中</span>
<span class="dt">int</span> normal_gauss_jordan(vector&lt;vector&lt;<span class="dt">double</span>&gt;&gt; A,vector&lt;<span class="dt">double</span>&gt;&amp; b){
    <span class="dt">const</span> <span class="dt">double</span> EPS = <span class="fl">1e-8</span>;
    <span class="dt">int</span> n = A.size();
    <span class="dt">int</span> m = A[<span class="dv">0</span>].size();
    <span class="dt">int</span> pi = <span class="dv">0</span>,pj = <span class="dv">0</span>;
    <span class="kw">while</span>(pi &lt; n <span class="kw">and</span> pj &lt; m){
        <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){ <span class="co">// pivot</span>
            <span class="kw">if</span>(abs(A[i][pj]) &gt; abs(A[pi][pj])){
                swap(A[i],A[pi]);
                swap(b[i],b[pi]);
            }
        }
        <span class="kw">if</span>(abs(A[pi][pj]) &gt; EPS){
            <span class="dt">double</span> d = A[pi][pj];
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                A[pi][j] /= d;
            }
            b[pi] /= d;
            <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){
                <span class="dt">double</span> k = A[i][pj];
                <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                    A[i][j] -= k * A[pi][j];
                }
                b[i] -= k*b[pi];
            }
            pi++;
        }
        pj++;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=pi;i&lt;n;i++){
        <span class="kw">if</span>(abs(b[i]) &gt; EPS){
            <span class="kw">return</span> none;
        }
    }
    <span class="kw">if</span>(pi &lt; m <span class="kw">or</span> pj &lt; m){
        <span class="kw">return</span> many;
    }
    <span class="kw">for</span>(<span class="dt">int</span> j=m<span class="dv">-1</span>;j&gt;=<span class="dv">0</span>;j--){
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;j;i++){
            b[i] -= b[j] * A[i][j];
        }
    }
    <span class="kw">return</span> one;
}</code></pre></div>
<h2 id="nと互いに素な数の個数"><span class="header-section-number">7.10</span> nと互いに素な数の個数</h2>
<p>EulerのTotient関数による。</p>
<div class="sourceCode" include="cpp/euler_totient.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// nと互いに素な数の個数</span>
<span class="co">// n (1-1/p1) ... (1-1/pn)</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T totient(T n){
    <span class="kw">if</span>(n == <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">0</span>;
    T ans = n;
    <span class="kw">for</span>(T x=<span class="dv">2</span>;x*x &lt;= n;x++){
        <span class="kw">if</span>(n % x == <span class="dv">0</span>){
            ans -= ans/x;
            <span class="kw">while</span>(n % x == <span class="dv">0</span>) n /= x;
        }
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>){
        ans -= ans/n;
    }
    <span class="kw">return</span> ans;
}</code></pre></div>
<h1 id="行列"><span class="header-section-number">8</span> 行列</h1>
<h2 id="基本要素"><span class="header-section-number">8.1</span> 基本要素</h2>
<p>正方行列用 //いつかなおす。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 適宜intにしたりすること。</span>
<span class="kw">typedef</span> vector&lt;vector&lt;ll&gt; &gt; ll_mat;</code></pre></div>
<h2 id="基本演算"><span class="header-section-number">8.2</span> 基本演算</h2>
<p>かけ算とmod。たしざんはcoming soon.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std{
    ll_mat <span class="kw">operator</span>*(<span class="dt">const</span> ll_mat&amp; lhs,<span class="dt">const</span> ll_mat&amp; rhs){
        <span class="dt">int</span> N = lhs.size();
        ll_mat ret(N,vector&lt;ll&gt;(N));
        <span class="kw">for</span>(<span class="dt">int</span> row=<span class="dv">0</span>;row&lt;N;row++){
            <span class="kw">for</span>(<span class="dt">int</span> col=<span class="dv">0</span>;col&lt;N;col++){
                <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;N;k++){
                    ret[row][col] += rhs[row][k] * lhs[k][col];
                }
            }
        }
        <span class="kw">return</span> ret;
    }

    ll_mat <span class="kw">operator</span>%(ll_mat lhs,ll rhs){
        <span class="dt">int</span> N = lhs.size();
        ll_mat ret = lhs;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
                ret[i][j] = ret[i][j] % rhs;
            }
        }
        <span class="kw">return</span> ret;
    }
};</code></pre></div>
<h2 id="基本操作"><span class="header-section-number">8.3</span> 基本操作</h2>
<h3 id="累乗"><span class="header-section-number">8.3.1</span> 累乗</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;vector&lt;ll&gt; &gt;  mod_pow(vector&lt;vector&lt;ll&gt; &gt; x,ll n,ll mod){
    <span class="kw">if</span>(n==<span class="dv">0</span>){
        vector&lt;vector&lt;ll&gt; &gt; E(x.size(),vector&lt;ll&gt;(x.size()));
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;x.size();i++){
            E[i][i] = <span class="dv">1</span>;
        }
        <span class="kw">return</span> E;
    }
    vector&lt;vector&lt;ll&gt; &gt; ret = mod_pow(x * x % mod,n/<span class="dv">2</span>,mod);
    <span class="kw">if</span>(n%<span class="dv">2</span> == <span class="dv">1</span>)  ret = ret * x % mod;
    <span class="kw">return</span> ret;
}</code></pre></div>
<h3 id="表示"><span class="header-section-number">8.3.2</span> 表示</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> display_matrix(vector&lt;vector&lt;ll&gt; &gt; mat){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;mat.size();i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;mat[<span class="dv">0</span>].size();j++){
            cerr &lt;&lt; mat[i][j] &lt;&lt; <span class="st">&quot; &quot;</span>;
        }
        cerr &lt;&lt; endl;
    }
}</code></pre></div>
<h3 id="ベクトルとのかけ算"><span class="header-section-number">8.3.3</span> ベクトルとのかけ算</h3>
<p>一次元列ベクトルとのかけ算</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;ll&gt; mat_multi(vector&lt;vector&lt;ll&gt; &gt; lhs,vector&lt;ll&gt; rhs,<span class="dt">int</span> mod){
    vector&lt;ll&gt; ret(rhs.size());
    <span class="dt">int</span> N = lhs.size();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
            ret[i] = (ret[i] + lhs[i][j] * rhs[j]) % mod;;
        }
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="gauss-jordan"><span class="header-section-number">8.4</span> Gauss-Jordan</h2>
<p>GF上で連立方程式を解く</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Gauss-Jordan. Solve equation on GF.</span>
<span class="dt">int</span> invert(<span class="dt">int</span> x){
    <span class="dt">int</span> ret[<span class="dv">2</span>] = {<span class="dv">0</span>,<span class="dv">1</span>};
    <span class="kw">return</span> ret[x];
}

<span class="dt">int</span> modulo(<span class="dt">int</span> x){
    x %= <span class="dv">2</span>;
    <span class="kw">while</span>(x &lt; <span class="dv">0</span>){
        x += <span class="dv">2</span>;
    }
    <span class="kw">return</span> x;
}

<span class="dt">const</span> <span class="dt">int</span> none = <span class="dv">0</span>; <span class="co">// if no answer</span>
<span class="dt">const</span> <span class="dt">int</span> one = <span class="dv">1</span>;  <span class="co">// if there is exactly one answer</span>
<span class="dt">const</span> <span class="dt">int</span> many = <span class="dv">2</span>; <span class="co">// many answer.</span>
<span class="co">// answer will be inserted in b.</span>
<span class="dt">int</span> gauss(matrix A,vector&lt;<span class="dt">int</span>&gt;&amp; b){
    <span class="dt">int</span> n = A.size();
    <span class="dt">int</span> m = A[<span class="dv">0</span>].size();
    <span class="dt">int</span> pi = <span class="dv">0</span>,pj = <span class="dv">0</span>;
    <span class="kw">while</span>(pi &lt; n <span class="kw">and</span> pj &lt; m){
        <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){ <span class="co">// pivot</span>
            <span class="kw">if</span>(abs(A[i][pj]) &gt; abs(A[pi][pj])){
                swap(A[i],A[pi]);
                swap(b[i],b[pi]);
            }
        }
        <span class="kw">if</span>(abs(A[pi][pj]) &gt; <span class="dv">0</span>){
            <span class="dt">int</span> d = invert(A[pi][pj]);
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                A[pi][j] = modulo(A[pi][j] * d);
            }
            b[pi] = modulo(b[pi]*d);
            <span class="kw">for</span>(<span class="dt">int</span> i=pi<span class="dv">+1</span>;i&lt;n;i++){
                <span class="dt">int</span> k = A[i][pj];
                <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
                    A[i][j] = modulo(A[i][j] - k * A[pi][j]);
                }
                b[i] = modulo(b[i] - k*b[pi]);
            }
            pi++;
        }
        pj++;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=pi;i&lt;n;i++){
        <span class="kw">if</span>(abs(b[i]) &gt; <span class="dv">0</span>){
            <span class="kw">return</span> none;
        }
    }
    <span class="kw">if</span>(pi &lt; m <span class="kw">or</span> pj &lt; m){
        <span class="kw">return</span> many;
    }
    <span class="kw">for</span>(<span class="dt">int</span> j=m<span class="dv">-1</span>;j&gt;=<span class="dv">0</span>;j--){
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;j;i++){
            b[i] = modulo(b[i] - b[j] * A[i][j]);
        }
    }
    <span class="kw">return</span> one;
}</code></pre></div>
<h1 id="動的計画法およびそれに似たやつらtodo"><span class="header-section-number">9</span> 動的計画法およびそれに似たやつら。(TODO)</h1>
<h2 id="lcs"><span class="header-section-number">9.1</span> LCS</h2>
<p>Longest common sequence.O(NM)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string lcs(<span class="dt">const</span> string&amp; a,<span class="dt">const</span> string&amp; b){
    <span class="dt">const</span> <span class="dt">int</span> n = a.size(),m = b.size();
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; x(n<span class="dv">+1</span>,vector&lt;<span class="dt">int</span>&gt;(m<span class="dv">+1</span>));
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; y(n<span class="dv">+1</span>,vector&lt;<span class="dt">int</span>&gt;(m<span class="dv">+1</span>));

    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
            <span class="kw">if</span>(a[i] == b[j]){
                x[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = x[i][j]<span class="dv">+1</span>;
                y[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = <span class="dv">0</span>;
            }<span class="kw">else</span> <span class="kw">if</span>(x[i<span class="dv">+1</span>][j] &lt; x[i][j<span class="dv">+1</span>]){
                x[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = x[i][j<span class="dv">+1</span>];
                y[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = <span class="dv">1</span>;
            }<span class="kw">else</span>{
                x[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = x[i<span class="dv">+1</span>][j];
                y[i<span class="dv">+1</span>][j<span class="dv">+1</span>] = <span class="dv">-1</span>;
            }
        }
    }
    string ret;
    <span class="kw">for</span>(<span class="dt">int</span> i=n,j=m;i&gt;<span class="dv">0</span> <span class="kw">and</span> j&gt;<span class="dv">0</span>;){
        <span class="kw">if</span>(y[i][j] &gt; <span class="dv">0</span>){
            i--;
        }<span class="kw">else</span> <span class="kw">if</span>(y[i][j] &lt; <span class="dv">0</span>){
            j--;
        }<span class="kw">else</span>{
            ret.push_back(a[i<span class="dv">-1</span>]);
            i--;j--;
        }
    }
    reverse(all(ret));
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="lis"><span class="header-section-number">9.2</span> LIS</h2>
<h3 id="onlogn"><span class="header-section-number">9.2.1</span> O(NlogN)</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// O(Nlog(N))</span>
<span class="co">//  Sphagetthi source より.</span>
vector&lt;<span class="dt">int</span>&gt; longest_increasing_subsequence(<span class="dt">const</span> vector&lt;<span class="dt">int</span>&gt;&amp; a){
    <span class="dt">const</span> <span class="dt">int</span> n = a.size();
    vector&lt;<span class="dt">int</span>&gt; A(n,<span class="dv">1</span>&lt;&lt;<span class="dv">30</span>);
    vector&lt;<span class="dt">int</span>&gt; id(n);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        id[i] = distance(A.begin(),lower_bound(A.begin(),A.end(),a[i]));
        A[id[i]] = a[i];
    }
    <span class="dt">int</span> m = *max_element(id.begin(),id.end());
    vector&lt;<span class="dt">int</span>&gt; b(m<span class="dv">+1</span>);
    <span class="kw">for</span>(<span class="dt">int</span> i=n<span class="dv">-1</span>;i&gt;=<span class="dv">0</span>;i--){
        <span class="kw">if</span>(id[i] == m) b[m--] = a[i];
    }
    <span class="kw">return</span> b;
}</code></pre></div>
<h2 id="巡回セールスマン問題"><span class="header-section-number">9.3</span> 巡回セールスマン問題</h2>
<p>bit演算をする。bitのループを先に回すこと。<span class="math inline">\(O(N^2\times2^{N})\)</span></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ll dp[<span class="dv">1</span> &lt;&lt; N][N];
dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;
<span class="co">// Bitのほうが先!</span>
<span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;(<span class="dv">1</span>&lt;&lt;N);i++){
    <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;N;j++){
        <span class="co">//something.</span>
    }
}</code></pre></div>
<h2 id="ナップサック問題"><span class="header-section-number">9.4</span> ナップサック問題</h2>
<p>個数制限なしのとき</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define rep(i,n) for(int i=0;i&lt;(int)n;i++)</span>

<span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">inline</span> <span class="dt">int</span> len(<span class="dt">const</span> T&amp; t){
    <span class="kw">return</span> t.size();
}

<span class="kw">struct</span> Treasure{
    <span class="dt">int</span> value,weight;
    Treasure():
        value(<span class="dv">0</span>),weight(<span class="dv">0</span>) {};
    Treasure(<span class="dt">int</span> _value,<span class="dt">int</span> _weight)
        : value(_value),weight(_weight) {}
};

<span class="dt">int</span> main(){
    <span class="dt">int</span> W,N;
    cin &gt;&gt; W;
    cin &gt;&gt; N;
    vector&lt;Treasure&gt; v(N);
    repeat(i,N){
        cin &gt;&gt; v[i].value &gt;&gt; v[i].weight;
    }
    <span class="co">// もしも複数入れて良いなら、直接valueを更新する。</span>
    vi value(W<span class="dv">+1</span>);
    repeat(n,N){
        vi tmp(W<span class="dv">+1</span>);
        repeat(i,W<span class="dv">+1</span>){
            tmp[i] = max(tmp[i],value[i]);
            <span class="dt">int</span> in = i+v[n].weight;
            <span class="kw">if</span>(in &lt;= W){
                tmp[in] = max(tmp[in],value[i]+v[n].value);
            }
        }
        value.swap(tmp);
    }

    <span class="dt">int</span> retw=<span class="dv">0</span>;
    <span class="dt">int</span> retv=<span class="dv">0</span>;
    repeat(i,len(value)){
        <span class="kw">if</span>(value[i] &gt; retv){
            retv = value[i];
            retw = i;
        }
    }
    cout &lt;&lt; retv &lt;&lt; endl &lt;&lt; retw &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="ヒストグラム内の最大長方形のサイズ"><span class="header-section-number">9.5</span> ヒストグラム内の最大長方形のサイズ</h2>
<div class="sourceCode" include="cpp/hist.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define repeat(i,n) for(int i=0;i&lt;static_cast&lt;int&gt;(n);i++)</span>
<span class="kw">typedef</span> vector&lt;<span class="dt">int</span>&gt; vi;
<span class="kw">typedef</span> vector&lt;vi&gt; vvi;

<span class="co">// see http://algorithms.blog55.fc2.com/blog-entry-132.html</span>
<span class="co">//  max rectangle area in histogram.</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T max_rectangle_size_in_histogram(<span class="dt">const</span> vector&lt;T&gt;&amp; v){
    <span class="co">// where,height. in this function,use index as where.</span>
    <span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,T&gt; piT;
    stack&lt;piT&gt; sta;
    T ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;v.size();i++){
        <span class="kw">if</span>(sta.empty() <span class="kw">or</span> sta.top().second &lt; v[i]){
            sta.push(make_pair(i,v[i]));
        }<span class="kw">else</span> <span class="kw">if</span>(sta.top().second == v[i]){
            <span class="co">// pass</span>
        }<span class="kw">else</span> <span class="kw">if</span>(sta.top().second &gt; v[i]){
            piT t;
            <span class="kw">while</span>(<span class="kw">not</span> sta.empty() <span class="kw">and</span> sta.top().second &gt;= v[i]){
                t = sta.top();
                ret = max(ret,t.second*(i-t.first));
                sta.pop();
            }
            sta.push(make_pair(t.first,v[i]));
        }
    }
    <span class="dt">int</span> total_width = v.size();
    <span class="kw">while</span>(<span class="kw">not</span> sta.empty()){
        piT t = sta.top();
        sta.pop();
        ret = max(ret,t.second*(total_width-t.first));
    }
    <span class="kw">return</span> ret;
}

<span class="co">// square area </span>
<span class="dt">int</span> solve(<span class="dt">const</span> vvi &amp;matrix){
    <span class="dt">int</span> h = matrix.size();
    <span class="dt">int</span> w = matrix[<span class="dv">0</span>].size();
    vvi up(h,vi(w));

    {
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;h;i++){
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;w;j++){
                <span class="kw">if</span>(i == <span class="dv">0</span>){
                    up[i][j] = matrix[i][j] == <span class="dv">1</span>;
                }<span class="kw">else</span> {
                    <span class="kw">if</span>(matrix[i][j] == <span class="dv">0</span>){
                        up[i][j] = <span class="dv">0</span>;
                    }<span class="kw">else</span>{
                        up[i][j] = up[i<span class="dv">-1</span>][j]<span class="dv">+1</span>;
                    }
                }
            }
        }
    }

    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> y=<span class="dv">0</span>;y&lt;h;y++){
        ret = max(ret,max_rectangle_size_in_histogram(up[y]));
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="なんか長方形の和をもとめるやつ"><span class="header-section-number">9.6</span> なんか長方形の和をもとめるやつ</h2>
<div class="sourceCode" include="cpp/2d_area.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// ret[i][j] = sum of all field in [0,i) x [0,j).</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
vector&lt;vector&lt;T&gt;&gt; calc_sum(<span class="dt">const</span> vector&lt;vector&lt;T&gt;&gt;&amp; field){
    <span class="dt">int</span> h = field.size();
    <span class="dt">int</span> w = field[<span class="dv">0</span>].size();
    vector&lt;vector&lt;T&gt;&gt; ret(h<span class="dv">+1</span>,vector&lt;T&gt;(w<span class="dv">+1</span>));
    <span class="kw">for</span>(<span class="dt">int</span> y=<span class="dv">1</span>;y&lt;=h;y++){
        <span class="kw">for</span>(<span class="dt">int</span> x=<span class="dv">1</span>;x&lt;=w;x++){
            ret[y][x] = ret[y][x<span class="dv">-1</span>] + field[y<span class="dv">-1</span>][x<span class="dv">-1</span>];
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> x=<span class="dv">0</span>;x&lt;=w;x++){
        <span class="kw">for</span>(<span class="dt">int</span> y=<span class="dv">1</span>;y&lt;=h;y++){
            ret[y][x] = ret[y][x] + ret[y<span class="dv">-1</span>][x];
        }
    }
    <span class="kw">return</span> ret;
}

<span class="co">// calc [sy,gy] x [sx,gx]</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T calc(<span class="dt">const</span> vector&lt;vector&lt;T&gt;&gt;&amp; v,<span class="dt">int</span> sy,<span class="dt">int</span> sx,<span class="dt">int</span> gy,<span class="dt">int</span> gx){
    <span class="co">// for close section</span>
    gy++;gx++;
    <span class="kw">return</span> v[gy][gx] - v[sy][gx] - v[gy][sx] + v[sy][sx];
}

<span class="dt">int</span> main(){
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; field = {{<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>},
                                 {<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>},
                                 {<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>}};
    <span class="kw">auto</span> s = calc_sum(field);
    <span class="co">// calc 3+5+6 + 6+7+8</span>
    cout &lt;&lt; calc(s,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>) &lt;&lt; endl;

    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">// 座標圧縮</span>
<span class="dt">int</span> main(){
    <span class="dt">int</span> n,m;cin &gt;&gt; n &gt;&gt; m;

    vector&lt;<span class="dt">int</span>&gt; index_of_x(n),index_of_y(n);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        cin &gt;&gt; index_of_x[i] &gt;&gt; index_of_y[i];
    }
    vector&lt;<span class="dt">int</span>&gt; value_of_x = index_of_x,
                value_of_y = index_of_y;

    sort(all(value_of_x));
    sort(all(value_of_y));
    value_of_x.erase(unique(all(value_of_x)),value_of_x.end());
    value_of_y.erase(unique(all(value_of_y)),value_of_y.end());
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        index_of_x[i] = lower_bound(all(value_of_x),index_of_x[i]) - value_of_x.begin();
        index_of_y[i] = lower_bound(all(value_of_y),index_of_y[i]) - value_of_y.begin();
    }
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; p(value_of_y.size(),vector&lt;<span class="dt">int</span>&gt;(value_of_x.size()));
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        p[index_of_y[i]][index_of_x[i]] += <span class="dv">1</span>;
    }
    <span class="kw">auto</span> v = calc_sum(p);

    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
        <span class="dt">int</span> x1,y1,x2,y2;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;

        <span class="dt">int</span> sx = lower_bound(all(value_of_x),x1) - value_of_x.begin();
        <span class="dt">int</span> gx = upper_bound(all(value_of_x),x2) - value_of_x.begin();
        <span class="dt">int</span> sy = lower_bound(all(value_of_y),y1) - value_of_y.begin();
        <span class="dt">int</span> gy = upper_bound(all(value_of_y),y2) - value_of_y.begin();

        <span class="dt">int</span> ans = v[gy][gx] - v[sy][gx] - v[gy][sx] + v[sy][sx];
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="データ構造"><span class="header-section-number">10</span> データ構造</h1>
<h2 id="union-find"><span class="header-section-number">10.1</span> Union-Find</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> UnionFind{
    <span class="dt">const</span> <span class="dt">int</span> is_root = <span class="dv">-1</span>;
    vector&lt;<span class="dt">int</span>&gt; data;
    UnionFind(<span class="dt">int</span> n){
        data = vector&lt;<span class="dt">int</span>&gt;(n,<span class="dv">-1</span>);
    }
    <span class="co">// 親を探す</span>
    <span class="dt">int</span> root(<span class="dt">int</span> x){
        <span class="kw">if</span>(data[x] &lt; <span class="dv">0</span>){
            <span class="kw">return</span> x;
        }<span class="kw">else</span>{
            <span class="kw">return</span> data[x] = root(data[x]);
        }
    }
    <span class="co">// x,yの含まれる集合を併合</span>
    <span class="dt">bool</span> unite(<span class="dt">int</span> x,<span class="dt">int</span> y){
        x = root(x);
        y = root(y);
        <span class="kw">if</span>(x != y){
            <span class="co">// 大きいほうに追加する。</span>
            <span class="kw">if</span>(data[y] &lt; data[x]) swap(x,y);
            data[x] += data[y];
            data[y] = x;
            <span class="kw">return</span> <span class="kw">true</span>;
        }<span class="kw">else</span>{
            <span class="kw">return</span> <span class="kw">false</span>;
        }
    }
    <span class="co">// 同じ集合にいるかどうか</span>
    <span class="dt">bool</span> same(<span class="dt">int</span> x,<span class="dt">int</span> y){
        <span class="kw">return</span> root(x) == root(y);
    }
    <span class="dt">int</span> size(<span class="dt">int</span> x){
        <span class="kw">return</span> -data[root(x)];
    }
};</code></pre></div>
<h2 id="ヒープ"><span class="header-section-number">10.2</span> ヒープ</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Comp{
    <span class="dt">bool</span> <span class="kw">operator</span>()(pii left,pii right){
        <span class="kw">if</span>(left.second &lt; right.second) <span class="kw">return</span> <span class="kw">true</span>;
        <span class="kw">else</span> <span class="kw">if</span>(left.second == right.second <span class="kw">and</span> left.first &gt; right.first) <span class="kw">return</span> <span class="kw">true</span>;
        <span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;
    };
};

<span class="kw">struct</span> Robot{
    <span class="dt">int</span> y,x,dir,step;
    Robot(<span class="dt">int</span> y,<span class="dt">int</span> x,<span class="dt">int</span> dir,<span class="dt">int</span> step) : y(y),x(x),dir(dir),step(step) {};
};

<span class="co">// &lt;,&gt;を定義すればless&lt;Robot&gt;みたいに扱える。</span>
<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Robot&amp; lhs,<span class="dt">const</span> Robot&amp; rhs){
    <span class="kw">return</span> lhs.step &lt; rhs.step;
}
<span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="dt">const</span> Robot&amp; lhs,<span class="dt">const</span> Robot&amp; rhs){
    <span class="kw">return</span> lhs.step &gt; rhs.step;
}

<span class="dt">int</span> main(){
    <span class="co">// 何も書かないと降順。(おっきい方からでてくる。)</span>
    <span class="co">// これは昇順(ちいさいほうから出てくる)にしたもの。</span>
    priority_queue&lt;<span class="dt">int</span>,vector&lt;<span class="dt">int</span>&gt;,greater&lt;<span class="dt">int</span>&gt; &gt; Qi;
    <span class="co">//関数オブジェクトを使っていい感じにもできる。</span>
    priority_queue&lt;pii,vector&lt;pii&gt;,Comp&gt; Q;
    <span class="co">// 自作クラスの場合はこんな感じ</span>
    priority_queue&lt;Robot,vector&lt;Robot&gt;,greater&lt;Robot&gt; &gt; que;

    Q.push(make_pair(<span class="dv">1</span>,<span class="dv">2</span>));
    Q.push(make_pair(<span class="dv">2</span>,<span class="dv">2</span>));
    Q.push(make_pair(<span class="dv">3</span>,<span class="dv">2</span>));
    <span class="kw">while</span>(<span class="kw">not</span> Q.empty()){
        cout &lt;&lt; Q.top().first &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; Q.top().second &lt;&lt; endl;
        Q.pop();
    }
}</code></pre></div>
<h2 id="bitset"><span class="header-section-number">10.3</span> bitset</h2>
<p>限られた大きさのvector&lt;bool&gt;を使いたいときに、bitsetを使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;bitset&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dt">const</span> <span class="dt">int</span> N = <span class="dv">10</span>;

<span class="kw">struct</span> bit_cmp{
    <span class="dt">bool</span> <span class="kw">operator</span>() (<span class="dt">const</span> bitset&lt;N&gt; &amp;left,<span class="dt">const</span> bitset&lt;N&gt; &amp;right) {
        <span class="kw">for</span>(<span class="dt">int</span> i=N<span class="dv">-1</span>;i&gt;=<span class="dv">0</span>;i--){
            <span class="kw">if</span>(left[i] &lt; right[i]) <span class="kw">return</span> <span class="kw">true</span>;
            <span class="kw">if</span>(left[i] &gt; right[i]) <span class="kw">return</span> <span class="kw">false</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }
};


<span class="dt">int</span> main(){
    <span class="co">//定数じゃないとダメ。最初は全部false</span>
    bitset&lt;N&gt; bits;
    <span class="co">// すべての要素をtrue -&gt; 1111111111</span>
    bits.set();
    <span class="kw">if</span>(bits.all()) cout &lt;&lt; <span class="st">&quot;all&quot;</span> &lt;&lt; endl;
    <span class="co">// 立っているbitの数 -&gt; 10</span>
    cout &lt;&lt; bits.count() &lt;&lt; endl;
    <span class="co">// すべての要素をfalse -&gt; 0000000000</span>
    bits.reset();
    <span class="kw">if</span>(bits.none()) cout &lt;&lt; <span class="st">&quot;none&quot;</span> &lt;&lt; endl;

    <span class="co">//1番目の要素をtrue -&gt; 0100000000</span>
    bits.set(<span class="dv">1</span>);
    <span class="kw">if</span>(bits.any()) cout &lt;&lt; <span class="st">&quot;any&quot;</span> &lt;&lt; endl;

    <span class="co">// 0110000000</span>
    bits.set(<span class="dv">2</span>);
    <span class="co">//1番目の要素をfalse -&gt; 0010000000</span>
    bits.reset(<span class="dv">1</span>);

    <span class="kw">if</span>(bits[<span class="dv">2</span>]) cout &lt;&lt; <span class="dv">2</span> &lt;&lt; endl;
    cout &lt;&lt; bits &lt;&lt; endl;

    bitset&lt;N&gt; newbits;
    <span class="co">// 和を取る</span>
    bits |= newbits;
    <span class="co">// 積を取る</span>
    bits &amp;= newbits;

    <span class="co">// 関数オブジェクトを作る必要アリ</span>
    map&lt;bitset&lt;N&gt;,<span class="dt">int</span>,bit_cmp&gt; M;
}</code></pre></div>
<h2 id="分数"><span class="header-section-number">10.4</span> 分数</h2>
<p>テストちゅう.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;
ll gcd(ll a,ll b){
    <span class="kw">return</span> b==<span class="dv">0</span> ? a : gcd(b,a%b);
}

ll lcm(ll a,ll b){
    <span class="kw">if</span>(a &lt; <span class="dv">0</span>) a *= <span class="dv">-1</span>;
    <span class="kw">if</span>(b &lt; <span class="dv">0</span>) b *= <span class="dv">-1</span>;
    <span class="kw">return</span> a*b / gcd(a,b);
}

<span class="kw">struct</span> Fraction{
    ll n,d;
    Fraction(ll _n,ll _d){
        ll c = lcm(_n,_d);
        n = c / _d;
        d = c / _n;
        <span class="kw">if</span>(d &lt; <span class="dv">0</span>){
            n *= <span class="dv">-1</span>;
            d *= <span class="dv">-1</span>;
        }
    }

    Fraction(ll _n){
        Fraction(_n,<span class="dv">1</span>);
    }

    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        ll c_d = lcm(d,r.d);
        <span class="kw">return</span> n*(c_d/d)&lt; r.n*(c_d/r.d);
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> <span class="kw">not</span> ((*<span class="kw">this</span>) &lt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r);
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&lt;=(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) &lt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>&gt;=(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) &gt; r <span class="kw">or</span> (*<span class="kw">this</span>) == r;
    }
    <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> n == r.n <span class="kw">and</span> d == r.d;
    }
    Fraction <span class="kw">operator</span>+(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        ll c_d = lcm(d,r.d);
        <span class="kw">return</span> Fraction(n*(c_d/d)+r.n*(c_d/r.d),c_d);
    }
    Fraction <span class="kw">operator</span>-(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) + (-r);
    }
    Fraction <span class="kw">operator</span>*(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(n*r.n,d*r.d);
    }
    Fraction <span class="kw">operator</span>/(<span class="dt">const</span> Fraction&amp; r) <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) * Fraction(r.d,r.n);
    }
    Fraction <span class="kw">operator</span>+() <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(n,d);
    }
    Fraction <span class="kw">operator</span>-() <span class="dt">const</span>{
        <span class="kw">return</span> (*<span class="kw">this</span>) * <span class="dv">-1</span>;
    }
    Fraction <span class="kw">operator</span>*(<span class="dt">const</span> ll&amp; a) <span class="dt">const</span>{
        <span class="kw">return</span> Fraction(a*n,d) ;
    }
};

ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream &amp;os,<span class="dt">const</span> Fraction&amp; f){
    os &lt;&lt; f.n &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; f.d;
    <span class="kw">return</span> os;
}</code></pre></div>
<h2 id="セグメント木"><span class="header-section-number">10.5</span> セグメント木</h2>
<h3 id="普通の"><span class="header-section-number">10.5.1</span> 普通の</h3>
<p>RMQ (POJ 3264)</p>
<div class="sourceCode" include="cpp/segment_tree.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">struct</span> SegmentTree{
    <span class="co">// edit this things! Range Sum Query</span>
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> INIT_VALUE = <span class="dv">0</span>;
    <span class="kw">inline</span> <span class="dt">int</span> calc(<span class="dt">int</span> a,<span class="dt">int</span> b){
        <span class="kw">return</span> a+b;
    }

    <span class="co">// Range Minimum Query</span>
    <span class="co">// static const int INIT_VALUE = 1 &lt;&lt; 30;</span>
    <span class="co">// inline int calc(int a,int b){</span>
    <span class="co">//     return min(a,b);</span>
    <span class="co">// }</span>


    vector&lt;<span class="dt">int</span>&gt; data;
    <span class="dt">int</span> n;
    <span class="kw">explicit</span> SegmentTree(<span class="dt">int</span> _n){
        n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; _n) n *= <span class="dv">2</span>;
        data = vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>*n<span class="dv">-1</span>,INIT_VALUE);
    }

    <span class="dt">void</span> update(<span class="dt">int</span> i,<span class="dt">int</span> v){
        <span class="dt">int</span> k = i + n<span class="dv">-1</span>;
        data[k] = v;
        <span class="kw">while</span>(k &gt; <span class="dv">0</span>){
            k = parent(k);
            data[k] = calc(data[get_left(k)],data[get_right(k)]);
        }
    }

    <span class="co">// return data of [a,b).</span>
    <span class="kw">inline</span> <span class="dt">int</span> get(<span class="dt">int</span> a,<span class="dt">int</span> b){
        <span class="kw">return</span> get(a,b,<span class="dv">0</span>,<span class="dv">0</span>,n);
    }
<span class="kw">private</span>:
    <span class="co">// l,r is segment of node k.</span>
    <span class="dt">int</span> get(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r){
        <span class="kw">if</span>(r &lt;= a <span class="kw">or</span> b &lt;= l) <span class="kw">return</span> INIT_VALUE;
        <span class="kw">if</span>(a &lt;= l <span class="kw">and</span> r &lt;= b) <span class="kw">return</span> data[k];
        <span class="dt">int</span> vl = get(a,b,get_left(k),l,(l+r)/<span class="dv">2</span>);
        <span class="dt">int</span> vr = get(a,b,get_right(k),(l+r)/<span class="dv">2</span>,r);
        <span class="kw">return</span> calc(vl,vr);
    }

    <span class="kw">inline</span> <span class="dt">int</span> get_left(<span class="dt">int</span> x){
        <span class="kw">return</span> <span class="dv">2</span>*x<span class="dv">+1</span>;
    }
    <span class="kw">inline</span> <span class="dt">int</span> get_right(<span class="dt">int</span> x){
        <span class="kw">return</span> <span class="dv">2</span>*x<span class="dv">+2</span>;
    }
    <span class="kw">inline</span> <span class="dt">int</span> parent(<span class="dt">int</span> x){
        <span class="kw">return</span> (x<span class="dv">-1</span>)/<span class="dv">2</span>;
    }
};</code></pre></div>
<h3 id="lazy"><span class="header-section-number">10.5.2</span> Lazy</h3>
<p>テスト中 参考: http://d.hatena.ne.jp/kyuridenamida/20121114/1352835261</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;
<span class="co">// update [l,r) v -&gt; +v to all element in [l,r).</span>
<span class="co">// get [l,r) -&gt; return sum of elements in [l,r).</span>
<span class="kw">struct</span> LazySegmentTree{
    <span class="co">// also used for out of range value.</span>
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> DATA_INIT_VALUE = <span class="dv">0</span>;
    <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> LAZY_INIT_VALUE = <span class="dv">0</span>;
    vector&lt;<span class="dt">int</span>&gt; data;
    vector&lt;<span class="dt">int</span>&gt; lazy;
    <span class="dt">int</span> n;
    LazySegmentTree(<span class="dt">int</span> _n){
        n = <span class="dv">1</span>;
        <span class="kw">while</span>(n &lt; _n) n *= <span class="dv">2</span>;
        data = vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>*n<span class="dv">-1</span>,DATA_INIT_VALUE);
        lazy = vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>*n<span class="dv">-1</span>,LAZY_INIT_VALUE);
    }

    <span class="dt">int</span> get(<span class="dt">int</span> a,<span class="dt">int</span> b){
        <span class="kw">return</span> get(a,b,<span class="dv">0</span>,<span class="dv">0</span>,n);
    }
    <span class="dt">void</span> update(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v){
        <span class="kw">return</span> update(a,b,v,<span class="dv">0</span>,<span class="dv">0</span>,n);
    }


<span class="kw">private</span>:
    <span class="co">// edit update_lazy and update_data.</span>
    <span class="kw">inline</span> <span class="dt">void</span> update_lazy(<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r){
        data[k] += lazy[k]*(r-l);
        <span class="kw">if</span>(k &lt; n<span class="dv">-1</span>){ <span class="co">// node k has children</span>
            lazy[get_left(k)] += lazy[k];
            lazy[get_right(k)] += lazy[k];
        }
        lazy[k] = <span class="dv">0</span>;
        <span class="kw">return</span>;
    }
    <span class="kw">inline</span> <span class="dt">void</span> update_data(<span class="dt">int</span> k){
        data[k] = data[get_left(k)] + data[get_right(k)];
    }

    <span class="co">// l,r is segment of node k.</span>
    <span class="dt">int</span> get(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r){
        update_lazy(k,l,r);
        <span class="co">// [a,b) and [l,r) are not crossed</span>
        <span class="kw">if</span>(r &lt;= a <span class="kw">or</span> b &lt;= l) <span class="kw">return</span> DATA_INIT_VALUE;
        <span class="co">// [a,b) contains [l,r)</span>
        <span class="kw">if</span>(a &lt;= l <span class="kw">and</span> r &lt;= b) <span class="kw">return</span> data[k];
        <span class="dt">int</span> vl = get(a,b,get_left(k),l,(l+r)/<span class="dv">2</span>);
        <span class="dt">int</span> vr = get(a,b,get_right(k),(l+r)/<span class="dv">2</span>,r);
        update_data(k);
        <span class="kw">return</span> vl+vr;
    }
    <span class="dt">void</span> update(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> v,<span class="dt">int</span> k,<span class="dt">int</span> l,<span class="dt">int</span> r){
        update_lazy(k,l,r);
        <span class="co">// [a,b) and [l,r) are not crossed</span>
        <span class="kw">if</span>(r &lt;= a <span class="kw">or</span> b &lt;= l) <span class="kw">return</span>;
        <span class="co">// [a,b) contains [l,r)</span>
        <span class="kw">if</span>(a &lt;= l <span class="kw">and</span> r &lt;= b) {
            lazy[k] += v;
            update_lazy(k,l,r);
            <span class="kw">return</span>;
        }
        update(a,b,v,get_left(k),l,(l+r)/<span class="dv">2</span>);
        update(a,b,v,get_right(k),(l+r)/<span class="dv">2</span>,r);
        update_data(k);
        <span class="kw">return</span>;
    }

    <span class="kw">inline</span> <span class="dt">int</span> get_left(<span class="dt">int</span> x){
        <span class="kw">return</span> <span class="dv">2</span>*x<span class="dv">+1</span>;
    }
    <span class="kw">inline</span> <span class="dt">int</span> get_right(<span class="dt">int</span> x){
        <span class="kw">return</span> <span class="dv">2</span>*x<span class="dv">+2</span>;
    }
    <span class="co">// parent node is (n-1)/2.</span>
    <span class="kw">inline</span> <span class="dt">int</span> parent(<span class="dt">int</span> x){
        <span class="kw">return</span> (x<span class="dv">-1</span>)/<span class="dv">2</span>;
    }
};

ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os,<span class="dt">const</span> LazySegmentTree&amp; seg){
    os &lt;&lt; seg.data &lt;&lt; endl &lt;&lt; seg.lazy;
    <span class="kw">return</span> os;
}</code></pre></div>
<h2 id="定数個のみを保持するpriority_queue"><span class="header-section-number">10.6</span> 定数個のみを保持するpriority_queue</h2>
<p>ビームサーチとかに使える？</p>
<div class="sourceCode" include="cpp/lens_queue.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>


<span class="kw">template</span>&lt;<span class="kw">class</span> T,
         <span class="kw">class</span> Container=std::vector&lt;T&gt;,
         <span class="kw">class</span> Compare=std::less&lt;<span class="kw">typename</span> Container::value_type&gt;&gt;
<span class="kw">struct</span> lens_queue : <span class="kw">public</span> std::priority_queue&lt;T,Container,Compare&gt;{
    <span class="kw">typedef</span> std::priority_queue&lt;T,Container,Compare&gt; super;
    lens_queue(<span class="dt">int</span> _cap)
        : cap(_cap){
    }
    <span class="kw">inline</span> std::size_t capacity() <span class="dt">const</span> {<span class="kw">return</span> cap;}
    <span class="dt">void</span> push(<span class="dt">const</span> T&amp; x){
        <span class="kw">if</span>(should_push(x)){
            super::push(x);erase_overflow();
        }
    }
    <span class="dt">void</span> push(T&amp;&amp; x){
        <span class="kw">if</span>(should_push(x)){
            super::push(std::move(x));erase_overflow();
        }
    }
    <span class="kw">template</span> &lt;<span class="kw">class</span>... Args&gt;
    <span class="dt">void</span> emplace(Args&amp;&amp;... args){
        <span class="kw">this</span>-&gt;c.emplace_back(std::forward&lt;Args&gt;(args)...);
        <span class="kw">if</span>(should_push(<span class="kw">this</span>-&gt;c.back())){
            std::push_heap(<span class="kw">this</span>-&gt;c.begin(),<span class="kw">this</span>-&gt;c.end(),<span class="kw">this</span>-&gt;comp);
            erase_overflow();
        }<span class="kw">else</span>{
            <span class="kw">this</span>-&gt;c.pop_back();
        }
    }
    <span class="co">// this crash lens_queue.</span>
    Container&amp;&amp; take(){
        <span class="kw">return</span> std::move(<span class="kw">this</span>-&gt;c);
    }
    <span class="kw">template</span>&lt;<span class="kw">class</span> T2,<span class="kw">class</span> Container2,<span class="kw">class</span> Compare2&gt;
    <span class="kw">friend</span> std::ostream&amp; <span class="kw">operator</span>&lt;&lt;(std::ostream&amp;,
                                    <span class="dt">const</span> lens_queue&lt;T2,Container2,Compare2&gt;&amp;);
<span class="kw">private</span>:
    std::size_t cap;
    <span class="dt">void</span> erase_overflow(){
        <span class="kw">while</span>(<span class="kw">this</span>-&gt;size() &gt; capacity()){
            <span class="kw">this</span>-&gt;pop();
        }
    }
    <span class="kw">inline</span> <span class="dt">bool</span> should_push(<span class="dt">const</span> T&amp; x){
        <span class="kw">return</span> <span class="kw">this</span>-&gt;size()&lt;capacity() || !<span class="kw">this</span>-&gt;comp(<span class="kw">this</span>-&gt;top(),x);
    }
};

<span class="kw">template</span>&lt;<span class="kw">class</span> T,<span class="kw">class</span> Container,<span class="kw">class</span> Compare&gt;
std::ostream&amp; <span class="kw">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="dt">const</span> lens_queue&lt;T,Container,Compare&gt;&amp; que){
    os &lt;&lt; <span class="st">&quot;{&quot;</span>;
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; v : que.c){
        os &lt;&lt; v &lt;&lt; <span class="st">&quot;,&quot;</span>;
    }
    os &lt;&lt; <span class="st">&quot;}&quot;</span>;
    <span class="kw">return</span> os;
}



<span class="dt">signed</span> main() {
    <span class="dt">int</span> n,k;<span class="dt">char</span> c;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; c;
    <span class="kw">if</span>(c == <span class="st">&#39;g&#39;</span>){
        <span class="co">// k = 3</span>
        <span class="co">// 4 2 3 1 5 -&gt; 3 4 5</span>
        lens_queue&lt;<span class="dt">int</span>,std::vector&lt;<span class="dt">int</span>&gt;,std::greater&lt;<span class="dt">int</span>&gt;&gt; que(k);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="dt">int</span> v;std::cin &gt;&gt; v;
            que.push(v);
            <span class="co">// que.emplace(v);</span>
        }
        vector&lt;<span class="dt">int</span>&gt; taken = que.take();
        <span class="co">// while(not que.empty()){</span>
        <span class="co">//     std::cout &lt;&lt; que.top() &lt;&lt; std::endl;</span>
        <span class="co">//     que.pop();</span>
        <span class="co">// }</span>
    }<span class="kw">else</span> <span class="kw">if</span>(c == <span class="st">&#39;l&#39;</span>){
        <span class="co">// k = 3</span>
        <span class="co">// 4 2 3 1 5 -&gt; 3 2 1</span>
        lens_queue&lt;<span class="dt">int</span>&gt; que(k);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="dt">int</span> v;std::cin &gt;&gt; v;
            que.push(v);
            <span class="co">// que.emplace(v);</span>
        }
        <span class="kw">while</span>(<span class="kw">not</span> que.empty()){
            std::cout &lt;&lt; que.top() &lt;&lt; std::endl;
            que.pop();
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="グラフ"><span class="header-section-number">11</span> グラフ</h1>
<h2 id="構成要素"><span class="header-section-number">11.1</span> 構成要素</h2>
<p>隣接行列を使うか、vector&lt;Edge&gt;みたいのを使うかの二択。場合によってはNode<br />
みたいなのも使うかも。隣接行列を使うとメモリとか探すのとか重い。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cost;
    Edge(<span class="dt">int</span> to,<span class="dt">int</span> cost) : to(to),cost(cost) {};
};</code></pre></div>
<h2 id="ベルマンフォード"><span class="header-section-number">11.2</span> ベルマンフォード</h2>
<p>O(N|E|)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
<span class="co">// s:始点,dist:距離,prev:最短経路木</span>
<span class="dt">bool</span> bellman(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt; &gt;&amp; graph,<span class="dt">int</span> s,vector&lt;<span class="dt">int</span>&gt; &amp;dist,vector&lt;<span class="dt">int</span>&gt; &amp;prev){
    <span class="dt">int</span> n = graph.size();
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++) dist[i] = INF;
    dist[s] = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++) prev[i] = <span class="dv">-1</span>;

    <span class="dt">bool</span> neg_cycle = <span class="kw">false</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;n;j++){
            <span class="kw">for</span>(size_t k=<span class="dv">0</span>;k&lt;graph[j].size();k++){
                <span class="dt">const</span> Edge &amp;e = graph[j][k];
                <span class="kw">if</span>(dist[e.to] &gt; dist[j] + e.cost){
                    dist[e.to] = dist[j] + e.cost;
                    prev[e.to] = j;
                    <span class="kw">if</span>(i == n<span class="dv">-1</span>){
                        dist[e.to] = -INF;
                        neg_cycle = <span class="kw">true</span>;
                    }
                }
            }
        }
    }
    <span class="kw">return</span> !neg_cycle;
}</code></pre></div>
<h2 id="ダイクストラ"><span class="header-section-number">11.3</span> ダイクストラ</h2>
<p>負の経路があったらダメ</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;utility&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;functional&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> from,to,cost;
    Edge(<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cost)
        : from(from),to(to),cost(cost) {};
};

<span class="dt">int</span> dijkstra(<span class="dt">const</span> <span class="dt">int</span> start,<span class="dt">const</span> <span class="dt">int</span> goal,
             <span class="dt">const</span> vector&lt;vector&lt;Edge&gt; &gt; &amp;graph){
    <span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;
    <span class="dt">int</span> N = graph.size();
    vector&lt;<span class="dt">char</span>&gt; visited(N,<span class="kw">false</span>);
    <span class="co">// cost where</span>
    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;
    que.push(make_pair(<span class="dv">0</span>,start));
    <span class="kw">while</span>(<span class="kw">not</span> que.empty()){
        <span class="dt">int</span> cost,where;
        cost = que.top().first;
        where = que.top().second;
        que.pop();
        <span class="kw">if</span>(visited[where]) <span class="kw">continue</span>;
        <span class="kw">if</span>(where == goal) <span class="kw">return</span> cost;
        visited[where] = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;(<span class="dt">int</span>)graph[where].size();j++){
            que.push(make_pair(graph[where][j].cost+cost,graph[where][j].to));
        }
    }
    <span class="kw">return</span> <span class="dv">-1</span>;
}


<span class="dt">int</span> main(){
    <span class="dt">int</span> n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;Edge&gt; &gt; V(m);

    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="dt">int</span> a,b,cost;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; cost;
        V[a].push_back(Edge(a,b,cost));
        V[b].push_back(Edge(b,a,cost));
    }

    <span class="dt">int</span> ret = <span class="dv">-1</span>;
    <span class="dt">int</span> p,q;
    cin &gt;&gt; p &gt;&gt; q;
    vector&lt;<span class="dt">char</span>&gt; visited(m,<span class="kw">false</span>);
    <span class="co">//                 cost,where</span>
    priority_queue&lt;pii,vector&lt;pii&gt;, greater&lt;pii&gt; &gt; Q;
    Q.push(make_pair(<span class="dv">0</span>,p));
    <span class="kw">while</span>(!Q.empty()){
        <span class="dt">int</span> cost,where;
        cost = Q.top().first;
        where = Q.top().second;
        Q.pop();
        <span class="kw">if</span>(visited[where]) <span class="kw">continue</span>;
        <span class="kw">if</span>(where == q){
             ret = cost;
             <span class="kw">break</span>;
        }
        visited[where] = <span class="kw">true</span>;
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;(<span class="dt">int</span>)V[where].size();j++){
            Q.push(make_pair(V[where][j].cost+cost,V[where][j].to));
        }
    }
    <span class="co">// 到達不能なときは-1</span>
    cout &lt;&lt; ret &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="ワーシャルフロイド"><span class="header-section-number">11.4</span> ワーシャルフロイド</h2>
<p>負の経路があってもOK。すべてのノードに対してすべてのノードへの距離を求め<br />
る。もし負の閉路があったらiからiはマイナスになる。<span class="math inline">\(O(|V|^{3})\)</span></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// m はノードの個数。NOはでかい数</span>
vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; V(m,vector&lt;<span class="dt">int</span>&gt;(m,NO));
<span class="co">// i-&gt;iは0にする。</span>
rep(i,m){
    V[i][i] = <span class="dv">0</span>;
}

<span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;m;k++){
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;m;j++){
            V[i][j] = min(V[i][j],V[i][k]+V[k][j]);
        }
    }
}</code></pre></div>
<h2 id="最小全域木"><span class="header-section-number">11.5</span> 最小全域木</h2>
<p>プリム法による。<span class="math inline">\(O(N^2log(N))\)</span>だと思う。最小コストを求めるコードが以下。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to, cost;
    Edge(<span class="dt">int</span> to_,<span class="dt">int</span> cost_)
        : to(to_),cost(cost_) {}
};


vector&lt;vector&lt;Edge&gt;&gt; minimum_spanning_tree(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt; &amp;graph){
    <span class="kw">typedef</span> tuple&lt;<span class="dt">int</span>,<span class="dt">int</span>,<span class="dt">int</span>&gt; cft;  <span class="co">// cost,from,to</span>
    <span class="dt">int</span> N = graph.size();
    vector&lt;vector&lt;Edge&gt;&gt; ret(N);
    vector&lt;<span class="dt">char</span>&gt; used(N,<span class="kw">false</span>);
    priority_queue&lt;cft,vector&lt;cft&gt;,greater&lt;cft&gt;&gt; que;
    que.push(make_tuple(<span class="dv">0</span>,<span class="dv">-1</span>,<span class="dv">0</span>));
    <span class="kw">while</span>(<span class="kw">not</span> que.empty()){
        <span class="dt">int</span> cost = get&lt;<span class="dv">0</span>&gt;(que.top());
        <span class="dt">int</span> from = get&lt;<span class="dv">1</span>&gt;(que.top());
        <span class="dt">int</span> to = get&lt;<span class="dv">2</span>&gt;(que.top());
        que.pop();
        <span class="kw">if</span>(used[to]) <span class="kw">continue</span>;
        used[to] = <span class="kw">true</span>;
        <span class="co">// ignore first.</span>
        <span class="kw">if</span>(from != <span class="dv">-1</span>){
            ret[from].push_back(Edge(to,cost));
        }
        <span class="kw">for</span>(<span class="dt">const</span> Edge&amp; e : graph[to]){
            que.push(make_tuple(e.cost,to,e.to));
        }
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="最大流"><span class="header-section-number">11.6</span> 最大流</h2>
<p>Dinic法による。また、最大流最小カット定理より、最大流と最小カットは一致する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cap,rev;
    Edge(<span class="dt">int</span> _to,<span class="dt">int</span> _cap,<span class="dt">int</span> _rev) : to(_to),cap(_cap),rev(_rev) {};
};

<span class="dt">void</span> add_edge(vector&lt;vector&lt;Edge&gt; &gt;&amp; E,<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cap){
    E[from].push_back(Edge(to,cap,E[to].size()));
    E[to].push_back(Edge(from,<span class="dv">0</span>,E[from].size()<span class="dv">-1</span>));
}

vector&lt;<span class="dt">int</span>&gt; levels(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,<span class="dt">int</span> s){
    vector&lt;<span class="dt">int</span>&gt; level(E.size(),<span class="dv">-1</span>);
    level[s] = <span class="dv">0</span>;
    queue&lt;<span class="dt">int</span>&gt; Q;
    Q.push(s);
    <span class="kw">while</span>(!Q.empty()){
        <span class="dt">int</span> v = Q.front();
        Q.pop();
        <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;E[v].size();i++){
            Edge &amp;e = E[v][i];
            <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> level[e.to] == <span class="dv">-1</span>){
                level[e.to] = level[v]<span class="dv">+1</span>;
                Q.push(e.to);
            }
        }
    }
    <span class="kw">return</span> level;
}

<span class="dt">int</span> good_path(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,
        vector&lt;<span class="dt">int</span>&gt; &amp;iter,
        vector&lt;<span class="dt">int</span>&gt; &amp;level,
        <span class="dt">int</span> v,<span class="dt">int</span> t,<span class="dt">int</span> f){
    <span class="kw">if</span>(v == t) <span class="kw">return</span> f;
    <span class="kw">for</span>(<span class="dt">int</span> &amp;i=iter[v];i&lt;(<span class="dt">int</span>)E[v].size();i++){
        Edge &amp;e = E[v][i];
        <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> level[v] &lt; level[e.to]){
            <span class="dt">int</span> d = good_path(E,iter,level,e.to,t,min(f,e.cap));
            <span class="kw">if</span>(d &gt; <span class="dv">0</span>){
                e.cap -= d;
                E[e.to][e.rev].cap += d;
                <span class="kw">return</span> d;
            }
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> max_flow(vector&lt;vector&lt;Edge&gt; &gt; E,<span class="dt">int</span> s,<span class="dt">int</span> t){
    <span class="dt">int</span> flow = <span class="dv">0</span>;
    <span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
    <span class="kw">while</span>(<span class="kw">true</span>){
        vector&lt;<span class="dt">int</span>&gt; level = levels(E,s);
        <span class="kw">if</span>(level[t] &lt; <span class="dv">0</span>) <span class="kw">return</span> flow;
        vector&lt;<span class="dt">int</span>&gt; iter(E.size());
        <span class="dt">int</span> f;
        <span class="kw">while</span>((f=good_path(E,iter,level,s,t,INF)) &gt; <span class="dv">0</span>){
            flow += f;
        }
    }
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> N,M;
    <span class="kw">while</span>(cin &gt;&gt; N &gt;&gt; M){
        <span class="co">// [0,N) is cow,[N,N+M) is barn.</span>
        vector&lt;vector&lt;Edge&gt; &gt; E(N+M<span class="dv">+2</span>);
        <span class="dt">int</span> s = N+M;
        <span class="dt">int</span> t = N+M<span class="dv">+1</span>;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            add_edge(E,s,i,<span class="dv">1</span>);
        }
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;M;i++){
            add_edge(E,N+i,t,<span class="dv">1</span>);
        }

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            <span class="dt">int</span> S;
            cin &gt;&gt; S;
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;S;j++){
                <span class="dt">int</span> k;
                cin &gt;&gt; k;
                k--;
                add_edge(E,i,N+k,<span class="dv">1</span>);
            }
        }

        cout &lt;&lt; max_flow(E,s,t) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="最小費用流"><span class="header-section-number">11.7</span> 最小費用流</h2>
<p>Primal-Dual法による。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; pii;

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cap,cost,rev;
    Edge(<span class="dt">int</span> to,<span class="dt">int</span> cap,<span class="dt">int</span> cost,<span class="dt">int</span> rev)
        : to(to),cap(cap),cost(cost),rev(rev) {};
};

<span class="dt">void</span> add_edge(vector&lt;vector&lt;Edge&gt; &gt; &amp;E,<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cap,<span class="dt">int</span> cost){
    E[from].push_back(Edge(to,cap,cost,E[to].size()));
    E[to].push_back(Edge(from,<span class="dv">0</span>,-cost,E[from].size()<span class="dv">-1</span>));
}

<span class="co">// s -&gt; t (flow f)</span>
<span class="co">//  if cant, return -1.</span>
<span class="dt">int</span> min_cost_flow(vector&lt;vector&lt;Edge&gt; &gt; E,<span class="dt">int</span> s,<span class="dt">int</span> t,<span class="dt">int</span> f){
    <span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
    <span class="dt">int</span> ret = <span class="dv">0</span>;
    <span class="co">// potential</span>
    vector&lt;<span class="dt">int</span>&gt; h(E.size());
    vector&lt;<span class="dt">int</span>&gt; prevv(E.size());
    vector&lt;<span class="dt">int</span>&gt; preve(E.size());

    <span class="kw">while</span>(f &gt; <span class="dv">0</span>){
        vector&lt;<span class="dt">int</span>&gt; dist(E.size(),INF);
        dist[s] = <span class="dv">0</span>;
        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; que;
        que.push(make_pair(<span class="dv">0</span>,s));
        <span class="kw">while</span>(!que.empty()){
            pii p = que.top();
            que.pop();
            <span class="dt">int</span> pf = p.first,ps = p.second;
            <span class="kw">if</span>(dist[ps] &lt; pf) <span class="kw">continue</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;E[ps].size();i++){
                Edge &amp;e = E[ps][i];
                <span class="kw">if</span>(e.cap &gt; <span class="dv">0</span> <span class="kw">and</span> dist[e.to] &gt; dist[ps] + e.cost + h[ps] - h[e.to]){
                    dist[e.to] = dist[ps] + e.cost + h[ps] - h[e.to];
                    prevv[e.to] = ps;
                    preve[e.to] = i;
                    que.push(make_pair(dist[e.to],e.to));
                }
            }
        }
        <span class="kw">if</span>(dist[t] == INF){
            <span class="kw">return</span> <span class="dv">-1</span>;
        }
        <span class="kw">for</span>(<span class="dt">int</span> v=<span class="dv">0</span>;v&lt;E.size();v++){
            h[v] += dist[v];
        }
        <span class="dt">int</span> d = f;
        <span class="kw">for</span>(<span class="dt">int</span> v=t;v!=s;v=prevv[v]){
            d = min(d,E[prevv[v]][preve[v]].cap);
        }
        f -= d;
        ret += d * h[t];
        <span class="kw">for</span>(<span class="dt">int</span> v=t;v!=s;v=prevv[v]){
            Edge &amp;e = E[prevv[v]][preve[v]];
            e.cap -= d;
            E[v][e.rev].cap += d;
        }
    }
    <span class="kw">return</span> ret;
}

<span class="dt">int</span> main(){
    <span class="kw">while</span>(<span class="kw">true</span>){
        <span class="dt">int</span> N,M;
        cin &gt;&gt; N &gt;&gt; M;
        <span class="kw">if</span>(N == <span class="dv">0</span> <span class="kw">and</span> M == <span class="dv">0</span>) <span class="kw">break</span>;
        vector&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt; men;
        vector&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt; houses;
        <span class="kw">for</span>(<span class="dt">int</span> h=<span class="dv">0</span>;h&lt;N;h++){
            <span class="kw">for</span>(<span class="dt">int</span> w=<span class="dv">0</span>;w&lt;M;w++){
                <span class="dt">char</span> x;
                cin &gt;&gt; x;
                <span class="kw">if</span>(x == <span class="st">&#39;H&#39;</span>) houses.push_back(make_pair(h,w));
                <span class="kw">else</span> <span class="kw">if</span>(x == <span class="st">&#39;m&#39;</span>) men.push_back(make_pair(h,w));
            }
        }

        vector&lt;vector&lt;Edge&gt; &gt; E(men.size()+houses.size()<span class="dv">+2</span>);
        <span class="dt">int</span> s = men.size()+houses.size();
        <span class="dt">int</span> t = s<span class="dv">+1</span>;

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;men.size();i++){
            add_edge(E,s,i,<span class="dv">1</span>,<span class="dv">0</span>);
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;j&lt;houses.size();j++){
                <span class="dt">int</span> dist = abs(men[i].first - houses[j].first)
                    + abs(men[i].second - houses[j].second);
                add_edge(E,i,men.size()+j,<span class="dv">1</span>,dist);
            }
        }

        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;houses.size();i++){
            add_edge(E,men.size()+i,t,<span class="dv">1</span>,<span class="dv">0</span>);
        }

        cout &lt;&lt; min_cost_flow(E,s,t,men.size()) &lt;&lt; endl;
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="無向グラフにおける最小カット"><span class="header-section-number">11.8</span> 無向グラフにおける最小カット</h2>
<p>Nagamochi-Ibaraki/Storer-Wagnerの方法によってO(V^3)で計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cap,rev;
    Edge(<span class="dt">int</span> _to,<span class="dt">int</span> _cap,<span class="dt">int</span> _rev) : to(_to),cap(_cap),rev(_rev) {};
};

<span class="dt">void</span> add_edge(vector&lt;vector&lt;Edge&gt; &gt;&amp; E,<span class="dt">int</span> from,<span class="dt">int</span> to,<span class="dt">int</span> cap){
    E[from].push_back(Edge(to,cap,E[to].size()));
    E[to].push_back(Edge(from,<span class="dv">0</span>,E[from].size()<span class="dv">-1</span>));
}

<span class="co">// Nagamochi-Ibaraki/Stoer-Wagner</span>
<span class="co">//  http://www.prefield.com/algorithm/graph/minimum_cut.html</span>
<span class="dt">int</span> minimum_cut_of_undirected_graph(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt; &gt; &amp;graph){
    <span class="dt">const</span> <span class="dt">int</span> INF = <span class="dv">1</span> &lt;&lt; <span class="dv">30</span>;
    <span class="dt">int</span> n = graph.size();
    vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; adj(n,vector&lt;<span class="dt">int</span>&gt;(n));
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        <span class="kw">for</span>(size_t j=<span class="dv">0</span>;j&lt;graph[i].size();j++){
            Edge e = graph[i][j];
            adj[i][e.to] += e.cap;
        }
    }
    vector&lt;<span class="dt">int</span>&gt; h(n);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
        h[i] = i;
    }
    <span class="dt">int</span> cut = INF;
    <span class="kw">for</span>(<span class="dt">int</span> m = n;m &gt; <span class="dv">1</span>;m--){
        vector&lt;<span class="dt">int</span>&gt; ws(m,<span class="dv">0</span>);
        <span class="dt">int</span> u,v,w;
        <span class="kw">for</span>(<span class="dt">int</span> k=<span class="dv">0</span>;k&lt;m;k++){
            u = v;
            v = max_element(ws.begin(),ws.end()) - ws.begin();
            w = ws[v];
            ws[v] = <span class="dv">-1</span>;
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
                <span class="kw">if</span>(ws[i] &gt;= <span class="dv">0</span>) {
                    ws[i] += adj[h[v]][h[i]];
                }
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
            adj[h[i]][h[u]] += adj[h[i]][h[v]];
            adj[h[u]][h[i]] += adj[h[v]][h[i]];
        }
        h.erase(h.begin()+v);
        cut = min(cut,w);
    }
    <span class="kw">return</span> cut;
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> N,M;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>,&amp;N,&amp;M) != EOF){
        vector&lt;vector&lt;Edge&gt; &gt; graph(N);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;M;i++){
            <span class="dt">int</span> a,b,c;
            scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d\n</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c);
            add_edge(graph,a,b,c);
            add_edge(graph,b,a,c);
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>,minimum_cut_of_undirected_graph(graph));
    }
    <span class="kw">return</span> <span class="dv">0</span>;</code></pre></div>
<h2 id="強連結成分分解"><span class="header-section-number">11.9</span> 強連結成分分解</h2>
<div class="sourceCode" include="cpp/scc.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cost;
    Edge(<span class="dt">int</span> t,<span class="dt">int</span> c)
        :to(t),cost(c) {
    }
};

<span class="dt">void</span> check_back_number(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph,
                       <span class="dt">int</span> v,vector&lt;<span class="dt">char</span>&gt;&amp; used,vector&lt;<span class="dt">int</span>&gt;&amp; back_number){
    used[v] = <span class="kw">true</span>;
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; e : graph[v]){
        <span class="kw">if</span>(<span class="kw">not</span> used[e.to]){
            check_back_number(graph,e.to,used,back_number);
        }
    }
    back_number.push_back(v);
}

<span class="dt">void</span> collect_nodes(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt; &amp;graph,
                   <span class="dt">int</span> v,vector&lt;<span class="dt">char</span>&gt;&amp; used,vector&lt;<span class="dt">int</span>&gt;&amp; s){
    used[v] = <span class="kw">true</span>;
    s.push_back(v);
    <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; e : graph[v]){
        <span class="kw">if</span>(<span class="kw">not</span> used[e.to]) {
            collect_nodes(graph,e.to,used,s);
        }
    }
}

vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; strongly_connected_components(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph){
    <span class="dt">const</span> <span class="dt">int</span> N = graph.size();
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; scc;
    vector&lt;<span class="dt">int</span>&gt; back_number;
    {
        vector&lt;<span class="dt">char</span>&gt; used(N);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;N;i++){
            <span class="kw">if</span>(<span class="kw">not</span> used[i]){
                check_back_number(graph,i,used,back_number);
            }
        }
    }

    {
        vector&lt;<span class="dt">char</span>&gt; used(N);
        vector&lt;vector&lt;Edge&gt;&gt; reversed_graph(N);
        <span class="kw">for</span>(<span class="dt">int</span> from=<span class="dv">0</span>;from&lt;N;from++){
            <span class="kw">for</span>(<span class="dt">const</span> <span class="kw">auto</span>&amp; e : graph[from]){
                reversed_graph[e.to].push_back(Edge(from,e.cost));
            }
        }
        reverse(all(back_number));
        <span class="kw">for</span>(<span class="dt">int</span> k : back_number){
            <span class="kw">if</span>(<span class="kw">not</span> used[k]){
                scc.push_back(vector&lt;<span class="dt">int</span>&gt;());
                collect_nodes(reversed_graph,k,used,scc.back());
            }
        }
    }
    <span class="kw">return</span> scc;
}
<span class="kw">namespace</span> SAT{
    <span class="co">// variable is integer .</span>
    <span class="kw">struct</span> Literal{
        <span class="dt">bool</span> is_not;
        <span class="dt">int</span> var;
        Literal(<span class="dt">bool</span> _is_not,<span class="dt">int</span> _var)
            : is_not(_is_not),var(_var){}
        Literal not_() <span class="dt">const</span>{
            <span class="kw">return</span> Literal(<span class="kw">not</span> is_not,var);
        }
    };
    Literal make_yes(<span class="dt">int</span> var){
        <span class="kw">return</span> Literal(<span class="kw">false</span>,var);
    }
    Literal make_no(<span class="dt">int</span> var){
        <span class="kw">return</span> Literal(<span class="kw">true</span>,var);
    }
    <span class="kw">using</span> Clause = std::vector&lt;Literal&gt;;
    <span class="dt">bool</span> solve_2SAT(<span class="dt">const</span> <span class="dt">int</span> number_of_variable,
                    <span class="dt">const</span> vector&lt;Clause&gt;&amp; problem,
                    vector&lt;<span class="dt">char</span>&gt;&amp; output){
        <span class="co">// variable is [0..N).</span>
        <span class="co">// &quot;not n&quot; will be assigned to (n+N).</span>
        <span class="kw">auto</span> index = [number_of_variable](<span class="dt">const</span> <span class="dt">bool</span>&amp; is_not,<span class="dt">const</span> <span class="dt">int</span>&amp; var){
            <span class="kw">return</span> number_of_variable*is_not+var;
        };
        <span class="kw">auto</span> to_int = [number_of_variable,&amp;index](<span class="dt">const</span> Literal&amp; lit){
            <span class="kw">return</span> index(lit.is_not,lit.var);
        };

        vector&lt;vector&lt;Edge&gt;&gt; graph(number_of_variable*<span class="dv">2</span>);
        <span class="kw">for</span>(<span class="dt">const</span> Clause&amp; clause : problem){
            <span class="co">// clause = {Literal,Literal}</span>
            <span class="co">// a \/ b -&gt; ~a -&gt; b /\ ~b -&gt; a</span>
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">2</span>;i++){
                Literal c = clause[i].not_(),
                        d = clause[<span class="kw">not</span> i];
                graph[to_int(c)].push_back(Edge(to_int(d),<span class="dv">1</span>));
            }
        }
        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; scc = strongly_connected_components(graph);
        <span class="co">// where[i] = which component holds i</span>
        vector&lt;<span class="dt">int</span>&gt; where(number_of_variable*<span class="dv">2</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;scc.size();i++){
            <span class="kw">for</span>(<span class="dt">int</span> node : scc[i]){
                where[node] = i;
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> var=<span class="dv">0</span>;var&lt;number_of_variable;var++){
            <span class="kw">if</span>(where[index(<span class="kw">false</span>,var)] == where[index(<span class="kw">true</span>,var)]){
                <span class="kw">return</span> <span class="kw">false</span>;
            }
        }
        <span class="kw">for</span>(<span class="dt">int</span> var=<span class="dv">0</span>;var&lt;number_of_variable;var++){
            output[var] = where[index(<span class="kw">false</span>,var)] &lt; where[index(<span class="kw">true</span>,var)];
        }
        <span class="kw">return</span> <span class="kw">true</span>;
    }
}


<span class="co">// Codeforces 228E</span>
<span class="dt">signed</span> main() {
    ios::sync_with_stdio(<span class="kw">false</span>);
    cin.tie(<span class="dv">0</span>);
    <span class="dt">int</span> n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;SAT::Clause&gt; problem;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;m;i++){
        <span class="dt">int</span> a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        a--;b--;
        <span class="kw">if</span>(c){
            <span class="co">// already</span>
            <span class="co">// ~(A/\~B) /\ ~(~A/\B)</span>
            <span class="co">//  = (~A \/ B) /\ (A \/ ~B)</span>
            problem.push_back({SAT::make_no(a),SAT::make_yes(b)});
            problem.push_back({SAT::make_yes(a),SAT::make_no(b)});
        }<span class="kw">else</span>{
            <span class="co">// ~(A/\B) /\ ~(~A/\~B)</span>
            <span class="co">//  = (~A \/ ~B) /\ (A \/ B)</span>
            problem.push_back({SAT::make_no(a),SAT::make_no(b)});
            problem.push_back({SAT::make_yes(a),SAT::make_yes(b)});
        }
    }
    vector&lt;<span class="dt">char</span>&gt; output(n);
    <span class="dt">bool</span> is_solvable = SAT::solve_2SAT(n,problem,output);
    <span class="kw">if</span>(is_solvable){
        cout &lt;&lt; count(all(output),<span class="kw">true</span>) &lt;&lt; endl;
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;i++){
            <span class="kw">if</span>(output[i]){
                cout &lt;&lt; i<span class="dv">+1</span> &lt;&lt; <span class="st">&quot; &quot;</span>;
            }
        }
        cout &lt;&lt; endl;
    }<span class="kw">else</span>{
        cout &lt;&lt; <span class="st">&quot;Impossible&quot;</span> &lt;&lt; endl;
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="橋の列挙"><span class="header-section-number">11.10</span> 橋の列挙</h2>
<div class="sourceCode" include="cpp/bridge.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#define all(c) c.begin(),c.end()</span>
<span class="ot">#define repeat(i,n) for(int i=0;i&lt;static_cast&lt;int&gt;(n);i++)</span>

<span class="kw">struct</span> Edge{
    <span class="dt">int</span> to,cost;
    Edge(<span class="dt">int</span> to_,<span class="dt">int</span> cost_)
        :to(to_),cost(cost_){
    }
};

<span class="dt">int</span> find_bridge_sub(<span class="dt">int</span> cur,<span class="dt">int</span> from,<span class="dt">int</span> number,
                    <span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph,
                    vector&lt;<span class="dt">int</span>&gt; &amp;pre_order,
                    vector&lt;<span class="dt">int</span>&gt; &amp;low,
                    vector&lt;vector&lt;Edge&gt; &gt; &amp;bridges){
    pre_order[cur] = low[cur] = number;
    number++;
    <span class="kw">for</span>(<span class="dt">const</span> Edge&amp; e : graph[cur]){
        <span class="co">// not visited</span>
        <span class="kw">if</span>(pre_order[e.to] == <span class="dv">-1</span>){
            number = find_bridge_sub(e.to,cur,number,graph,pre_order,low,bridges);
            <span class="kw">if</span>(pre_order[e.to] == low[e.to]){
                bridges[cur].push_back(e);
            }
        }
        <span class="kw">if</span>(from != e.to){ <span class="co">//ignore parent.</span>
            low[cur] = min(low[cur],low[e.to]);
        }
    }
    <span class="kw">return</span> number;
}

<span class="co">// assume it is connected graph.</span>
vector&lt;vector&lt;Edge&gt;&gt; find_bridge(<span class="dt">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph){
    <span class="dt">int</span> N = graph.size();
    vector&lt;<span class="dt">int</span>&gt; pre_order(N,<span class="dv">-1</span>),lowest_number_of_connected(N,N<span class="dv">+1</span>);
    vector&lt;vector&lt;Edge&gt;&gt; ret(N);
    find_bridge_sub(<span class="dv">0</span>,<span class="dv">-1</span>,<span class="dv">0</span>,graph,pre_order,lowest_number_of_connected,ret);

    <span class="co">// optional: make sure from &lt; e.to</span>
    <span class="co">//  You can use following if graph is bidirectional.</span>
    <span class="co">// vector&lt;vector&lt;Edge&gt;&gt; swapped(N);</span>
    <span class="co">// repeat(f,graph.size()){</span>
    <span class="co">//     for(const Edge&amp; e: ret[f]){</span>
    <span class="co">//         if(f &lt; e.to){</span>
    <span class="co">//             swapped[f].push_back(e);</span>
    <span class="co">//         }else{</span>
    <span class="co">//             swapped[e.to].push_back(Edge(f,e.cost));</span>
    <span class="co">//         }</span>
    <span class="co">//     }</span>
    <span class="co">// }</span>
    <span class="co">// ret = swapped;</span>
    <span class="kw">return</span> ret;
}


<span class="dt">int</span> main(){
    <span class="dt">int</span> V_SIZE,E_SIZE;
    cin &gt;&gt; V_SIZE &gt;&gt; E_SIZE;
    vector&lt;vector&lt;Edge&gt;&gt; graph(V_SIZE);
    repeat(i,E_SIZE){
        <span class="dt">int</span> s,t;
        cin &gt;&gt; s &gt;&gt; t;
        graph[s].push_back(Edge(t,<span class="dv">1</span>));
        graph[t].push_back(Edge(s,<span class="dv">1</span>));
    }

    vector&lt;vector&lt;Edge&gt;&gt; bridges = find_bridge(graph);
    repeat(f,graph.size()){
        vector&lt;Edge&gt; &amp;es = bridges[f];
        sort(all(es),[](Edge lhs,Edge rhs){<span class="kw">return</span> lhs.to &lt; rhs.to;});
        <span class="kw">for</span>(<span class="dt">const</span> Edge&amp; e : es){
            cout &lt;&lt; f &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; e.to &lt;&lt; endl;
        }
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="lowest-common-ancestor"><span class="header-section-number">11.11</span> Lowest Common Ancestor</h2>
<p>木において、根から最も遠い、u,vの共通の祖先をLCAと呼ぶ。</p>
<div class="sourceCode" include="cpp/lca.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// lowest common ancestor.</span>
<span class="co">//  queue version.</span>
<span class="kw">struct</span> LCASolver{
    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; children;
    <span class="dt">int</span> root;
    <span class="co">// if root,parent is -1.</span>
    vector&lt;<span class="dt">int</span>&gt; parent;
    vector&lt;<span class="dt">int</span>&gt; depth;

    vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; parent_pow2;

    LCASolver(vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; children_,<span class="dt">int</span> root_)
        : children(children_),root(root_){
        calc_parent_and_depth();
        calc_parent_pow2();
    };
    
    <span class="dt">int</span> lca(<span class="dt">int</span> u,<span class="dt">int</span> v){
        <span class="co">// make sure depth(u) &gt; depth(v).</span>
        <span class="kw">if</span>(depth[u] &lt; depth[v]) swap(u,v);
        <span class="kw">for</span>(size_t k=<span class="dv">0</span>;k&lt;parent_pow2.size();k++){
            <span class="kw">if</span>(((depth[u] - depth[v]) &gt;&gt; k) &amp; <span class="dv">1</span>){
                u = parent_pow2[k][u];
            }
        }

        <span class="kw">if</span>(u == v) <span class="kw">return</span> u;
        <span class="kw">for</span>(<span class="dt">int</span> k=(<span class="dt">int</span>)parent_pow2.size()<span class="dv">-1</span>;k&gt;=<span class="dv">0</span>;k--){
            <span class="kw">if</span>(parent_pow2[k][u] != parent_pow2[k][v]){
                u = parent_pow2[k][u];
                v = parent_pow2[k][v];
            }
        }
        <span class="kw">return</span> parent_pow2[<span class="dv">0</span>][u];
    }

<span class="kw">private</span>:
    <span class="dt">void</span> calc_parent_and_depth(){
        parent = vector&lt;<span class="dt">int</span>&gt;(children.size(),<span class="dv">-1</span>);
        depth = vector&lt;<span class="dt">int</span>&gt;(children.size(),<span class="dv">-1</span>);
        sub_calc_parent_and_depth(root,<span class="dv">-1</span>,<span class="dv">0</span>);
    }
    <span class="dt">void</span> sub_calc_parent_and_depth(<span class="dt">int</span> cur,<span class="dt">int</span> par,<span class="dt">int</span> dep){
        parent[cur] = par;
        depth[cur] = dep;
        <span class="kw">for</span>(<span class="dt">int</span> child : children[cur]){
            <span class="kw">if</span>(child != par){
                sub_calc_parent_and_depth(child,cur,dep<span class="dv">+1</span>);
            }
        }
    }
    <span class="dt">void</span> calc_parent_pow2(){
        <span class="co">// parent_pow2[k][i] = 2^k parent of node i.</span>
        parent_pow2 = vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;(ceil(log(children.size())/log(<span class="dv">2</span>)),
                                          vector&lt;<span class="dt">int</span>&gt;(children.size(),<span class="dv">-1</span>));
        parent_pow2[<span class="dv">0</span>] = parent;
        <span class="kw">for</span>(size_t k=<span class="dv">0</span>;k<span class="dv">+1</span>&lt;parent_pow2.size();k++){
            <span class="kw">for</span>(size_t v=<span class="dv">0</span>;v&lt;children.size();v++){
                <span class="kw">if</span>(parent_pow2[k][v] &gt;= <span class="dv">0</span>){
                    parent_pow2[k<span class="dv">+1</span>][v] = parent_pow2[k][parent_pow2[k][v]];
                }
            }
        }
    }
};</code></pre></div>
<h1 id="幾何"><span class="header-section-number">12</span> 幾何</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;complex&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">double</span> EPS = <span class="fl">1e-9</span>;
<span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; point;
<span class="kw">typedef</span> vector&lt;point&gt; vertex;

<span class="kw">namespace</span> std{
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="dt">const</span> point &amp;lhs,<span class="dt">const</span> point &amp;rhs){
        <span class="kw">if</span>(real(lhs) == real(rhs)){
            <span class="kw">return</span> imag(lhs) &lt; imag(rhs);
        }<span class="kw">else</span>{
            <span class="kw">return</span> real(lhs) &lt; real(rhs);
        }
    }
}

<span class="co">// ベクタの長さ</span>
<span class="dt">double</span> vector_length(point a){
    <span class="kw">return</span> abs(a);
}

<span class="co">// 二点間距離</span>
<span class="dt">double</span> point_distance(point a,point b){
    <span class="kw">return</span> abs(a-b);
}

<span class="co">// 単位ベクトル</span>
point unit_vector(point a){
    <span class="kw">return</span> a / abs(a);
}

<span class="co">// 法線ベクトル</span>
pair&lt;point,point&gt; normal_vector(point a){
    point n1 = a * point(<span class="dv">0</span>,<span class="dv">1</span>);
    point n2 = a * point(<span class="dv">0</span>,<span class="dv">-1</span>);
    <span class="kw">return</span> make_pair(n1,n2);
}

<span class="co">// 点が一緒かどうか</span>
<span class="dt">bool</span> point_eq(point a,point b){
    <span class="kw">return</span> abs(a-b) &lt; EPS;
}
<span class="co">// 内積 (dot product) : a・b = |a||b|cosΘ</span>
<span class="dt">double</span> dot(point a,point b){
    <span class="kw">return</span> real(conj(a)*b);
}

<span class="co">// 外積 (cross product) : |a×b| = |a||b|sinΘ</span>
<span class="dt">double</span> cross(point a,point b){
    <span class="kw">return</span> imag(conj(a)*b);
}

<span class="co">// rotate by theta (-pi,+pi)</span>
<span class="co">// arg will return angle of point</span>
point rotate(point p,<span class="dt">double</span> theta){
    <span class="dt">double</span> cos_theta = cos(theta),
           sin_theta = sin(theta);
    <span class="kw">return</span> point(p.real()*cos_theta - p.imag()*sin_theta,
                 p.real()*sin_theta + p.imag()*cos_theta);
}
<span class="co">// 二つの円の共通接線 (たぶんおかしい)</span>
<span class="co">//  http://www.ftext.org/text/subsubsection/1427</span>
<span class="co">//  - 離れている → 4本</span>
<span class="co">//  - 外接している → 3本</span>
<span class="co">//  - 交わっている → 2本</span>
<span class="co">//  - 内接している → 1本</span>
<span class="co">//  - 含む → 0本</span>
vector&lt;pair&lt;point,point&gt; &gt; common_tangent_of_two_circles(point c1,<span class="dt">double</span> r1,point c2,<span class="dt">double</span> r2){
    <span class="co">// shift c2 by c1.</span>
    point nc = c2 - c1;
    <span class="co">// c.img == 0</span>
    <span class="dt">double</span> ar = arg(nc);
    point c = rotate(nc,-ar);

    vector&lt;pair&lt;point,point&gt; &gt; ret;
    vector&lt;<span class="dt">double</span>&gt; xs;
    <span class="kw">for</span>(<span class="dt">int</span> sign=<span class="dv">-1</span>;sign&lt;=<span class="dv">1</span>;sign+=<span class="dv">2</span>){
        xs.push_back((r1*r1 + sign*r1*r2)/c.real());
    }
    <span class="kw">for</span>(<span class="dt">double</span> x1 : xs){
        <span class="dt">double</span> y2 = r1*r1 - x1*x1;
        <span class="kw">if</span>(y2 &lt; EPS) <span class="kw">continue</span>; <span class="co">// maybe two circle is crossed</span>
        <span class="kw">for</span>(<span class="dt">int</span> sign=<span class="dv">-1</span>;sign&lt;=<span class="dv">1</span>;sign+=<span class="dv">2</span>){
            <span class="dt">double</span> y1 = sign*sqrt(y2);
            <span class="co">// x1*x + y1*y = r1*r1 is such line</span>
            point h = point(x1,y1);
            point t = point(x1<span class="dv">+1</span>,(-x1*(x1<span class="dv">+1</span>)+r1*r1)/y1); <span class="co">// tekito</span>
            <span class="kw">if</span>(abs(y1) &lt; EPS){
                t = point(x1,y1);
            }

            ret.push_back(make_pair(h,t));
        }
    }
    transform(ret.begin(),ret.end(),ret.begin(),[ar,c1](pair&lt;point,point&gt; p){
            <span class="kw">return</span> make_pair(rotate(p.first,ar)+c1,
                             rotate(p.second,ar)+c1);
        });
    <span class="kw">return</span> ret;
}


<span class="co">// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定</span>
<span class="dt">bool</span> is_intersected_linesegment(point a1,point a2,point b1,point b2){
    <span class="kw">if</span>(max(a1.real(),a2.real()) + EPS &lt; min(b1.real(),b2.real())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(b1.real(),b2.real()) + EPS &lt; min(a1.real(),a2.real())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(a1.imag(),a2.imag()) + EPS &lt; min(b1.imag(),b2.imag())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span>(max(b1.imag(),b2.imag()) + EPS &lt; min(a1.imag(),a2.imag())) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">return</span> (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) &lt; EPS) <span class="kw">and</span>
           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) &lt; EPS);

}

<span class="co">// 与えられた4点が正方形を成すかどうかを判定する</span>
<span class="co">// ただし，ほぼ同じ点が含まれたときにはfalseとする</span>
<span class="co">//  4辺および対角線が1:1:1:1:sqrt(2):sqrt(2)ならばyes</span>
<span class="dt">bool</span> is_square(vector&lt;point&gt; ps){
    <span class="co">// assert ps.size() == 4</span>
    sort(ps.begin(),ps.end());
    vector&lt;<span class="dt">double</span>&gt; dist;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">4</span>;i++){
        <span class="kw">for</span>(<span class="dt">int</span> j=i<span class="dv">+1</span>;j&lt;<span class="dv">4</span>;j++){
            <span class="co">// there is almost same point</span>
            <span class="kw">if</span>(abs(ps[i] - ps[j]) &lt; EPS) <span class="kw">return</span> <span class="kw">false</span>;
            dist.push_back(abs(ps[i]-ps[j]));
        }
    }
    sort(dist.begin(),dist.end());
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;<span class="dv">4</span>;i++){
        <span class="kw">if</span>(abs(dist[<span class="dv">0</span>] - dist[i]) &gt; EPS) <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">4</span>;i&lt;<span class="dv">6</span>;i++){
        <span class="kw">if</span>(abs(sqrt(<span class="dv">2</span>)*dist[<span class="dv">1</span>]-dist[i]) &gt; EPS) <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}


<span class="co">// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算</span>
point intersection_point_linesegment(point a1,point a2,point b1,point b2) {
    <span class="kw">if</span>(a1 == b1 <span class="kw">or</span> a1 == b2) <span class="kw">return</span> a1;
    <span class="kw">if</span>(a2 == b1 <span class="kw">or</span> a2 == b2) <span class="kw">return</span> a2;
    point b = b2-b1;
    <span class="dt">double</span> d1 = abs(cross(b, a1-b1));
    <span class="dt">double</span> d2 = abs(cross(b, a2-b1));
    <span class="dt">double</span> t = d1 / (d1 + d2);
    <span class="kw">return</span> a1 + (a2-a1) * t;
}

<span class="co">// 線分同士の最短距離</span>
<span class="dt">double</span> dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){
    <span class="kw">if</span>(is_intersected_linesegment(a1,a2,b1,b2)){
        <span class="kw">return</span> <span class="dv">0</span>;
    }
    <span class="kw">return</span> min(min(dist_linesegment_and_point(a1,a2,b1),
               dist_linesegment_and_point(a1,a2,b2)),
           min(dist_linesegment_and_point(b1,b2,a1),
               dist_linesegment_and_point(b1,b2,a2)));
}


<span class="co">// 2直線の直交判定 : a⊥b &lt;=&gt; dot(a, b) = 0</span>
<span class="co">// みけんしょう</span>
<span class="dt">bool</span> is_orthogonal(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> dot(a1-a2,b1-b2) &lt; EPS;
}

<span class="co">// 2直線の平行判定 : a//b &lt;=&gt; cross(a, b) = 0</span>
<span class="dt">bool</span> is_parallel(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> abs(cross(a2-a1,b2-b1)) &lt; EPS;
}

<span class="co">// a1,a2を通る直線とb1,b2を通る直線の交差判定</span>
<span class="dt">bool</span> is_intersected_line(point a1,point a2,point b1,point b2) {
    <span class="kw">return</span> <span class="kw">not</span> is_parallel(a1,a2,b1,b2);
}

<span class="co">// a1,a2を通る直線とb1,b2を通る直線の交点計算</span>
point intersection_line(point a1,point a2,point b1,point b2) {
    point a = a2 - a1,b = b2 - b1;
    <span class="kw">return</span> a1 + a * cross(b, b1-a1) / cross(b, a);
}

<span class="co">// 直線と点との距離</span>
<span class="dt">double</span> dist_line_and_point(point a1,point a2,point b){
    <span class="kw">return</span> abs(cross(a2-a1,b-a1)) / abs(a2-a1);
}

<span class="co">// 線分と点との距離</span>
<span class="dt">double</span> dist_linesegment_and_point(point a1,point a2,point b){
    <span class="kw">if</span>(dot(a2-a1,b-a1) &lt; EPS) <span class="kw">return</span> abs(b-a1);
    <span class="kw">if</span>(dot(a1-a2,b-a2) &lt; EPS) <span class="kw">return</span> abs(b-a2);
    <span class="kw">return</span> dist_line_and_point(a1,a2,b);
}

<span class="co">// 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)</span>
point nearest_point_line_and_point(point a1,point a2,point b){
    <span class="kw">return</span> a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);
}

<span class="co">// 線分と点の最短距離を実現する線分嬢の点(みけんしょう)</span>
point nearest_point_linesegment_and_point(point a1,point a2,point b){
    <span class="kw">if</span>(dot(a2-a1,b-a1) &lt; EPS) <span class="kw">return</span> a1;
    <span class="kw">if</span>(dot(a1-a2,b-a2) &lt; EPS) <span class="kw">return</span> a2;
    <span class="kw">return</span> nearest_point_line_and_point(a1,a2,b);
}
<span class="co">// 円と線分の交差判定</span>
<span class="dt">bool</span> is_cross_linesegment_and_circle(point c,<span class="dt">double</span> r,point a1,point a2){
    <span class="kw">return</span> (dist_linesegment_and_point(a1,a2,c) &lt; r+EPS <span class="kw">and</span>
             (r &lt; abs(c-a1) + EPS <span class="kw">or</span> r &lt; abs(c-a2) + EPS));
}


<span class="co">// 点の進行方向</span>
<span class="dt">int</span> ccw(point a,point b,point c){
    b -= a;c -= a;
    <span class="kw">if</span>(cross(b,c) &gt; <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">+1</span>;    <span class="co">// counter clockwise</span>
    <span class="kw">if</span>(cross(b,c) &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">-1</span>;    <span class="co">// clockwise</span>
    <span class="kw">if</span>(dot(b,c) &lt; <span class="dv">0</span>) <span class="kw">return</span> <span class="dv">+2</span>;      <span class="co">// c -- a -- b</span>
    <span class="kw">if</span>(norm(b) &lt; norm(c)) <span class="kw">return</span> <span class="dv">-2</span>; <span class="co">// a -- b -- c</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="co">// 点が真に多角形(凸?)の中にはいっているか</span>
<span class="dt">bool</span> is_inner_point_vertex(<span class="dt">const</span> vector&lt;point&gt; &amp;ps,point a){
    <span class="dt">int</span> cc = ccw(ps[<span class="dv">0</span>],ps[<span class="dv">1</span>],a);
    <span class="kw">if</span>(<span class="kw">not</span>(cc == <span class="dv">1</span> <span class="kw">or</span> cc == <span class="dv">-1</span>)) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;ps.size();i++){
        <span class="kw">if</span>(cc != ccw(ps[i],ps[(i<span class="dv">+1</span>)%ps.size()],a)) <span class="kw">return</span> <span class="kw">false</span>;
    }
    <span class="kw">return</span> <span class="kw">true</span>;
}

<span class="co">// 点が辺上、もしくは内部にある。(未検証)</span>
<span class="dt">bool</span> is_inner_point_vertex_or_line(<span class="dt">const</span> vector&lt;point&gt; &amp;ps,point a){
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;ps.size();i++){
        <span class="kw">if</span>(dist_linesegment_and_point(ps[i],ps[(i<span class="dv">+1</span>)%ps.size()],a) &lt; EPS){
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">return</span> is_inner_point_vertex(ps,a);
}


<span class="co">// 凸包 (UVA 109)</span>
vector&lt;point&gt; convex_hull(vector&lt;point&gt; ps){
    <span class="dt">int</span> n = ps.size();
    <span class="dt">int</span> k = <span class="dv">0</span>;
    sort(ps.begin(),ps.end());
    vector&lt;point&gt; ch(<span class="dv">2</span>*n);
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;n;ch[k++] = ps[i++]){
        <span class="kw">while</span>(k &gt;= <span class="dv">2</span> <span class="kw">and</span> ccw(ch[k<span class="dv">-2</span>],ch[k<span class="dv">-1</span>],ps[i]) &lt;= <span class="dv">0</span>) --k;
    }
    <span class="kw">for</span>(<span class="dt">int</span> i=n<span class="dv">-2</span>,t=k<span class="dv">+1</span>;i&gt;=<span class="dv">0</span>;ch[k++]=ps[i--]){
        <span class="kw">while</span>(k &gt;= t <span class="kw">and</span> ccw(ch[k<span class="dv">-2</span>],ch[k<span class="dv">-1</span>],ps[i]) &lt;= <span class="dv">0</span>) --k;
    }
    ch.resize(k<span class="dv">-1</span>);
    <span class="kw">return</span> ch;
}

<span class="co">// remember,pts make convex.</span>
<span class="co">// (http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACAC002&amp;pid=C)</span>
<span class="dt">double</span> convex_diameter(<span class="dt">const</span> vector&lt;point&gt;&amp; pts){
    <span class="dt">const</span> <span class="dt">int</span> n = pts.size();
    <span class="dt">int</span> is=<span class="dv">0</span>,js=<span class="dv">0</span>; <span class="co">// initial antipode.</span>
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;n;i++){
        <span class="kw">if</span>(pts[i].imag() &gt; pts[is].imag()) is = i;
        <span class="kw">if</span>(pts[i].imag() &lt; pts[js].imag()) js = i;
    }
    <span class="dt">double</span> maxd = abs(pts[is]-pts[js]);
    <span class="dt">int</span> i,j,maxi,maxj;
    i = maxi = is;
    j = maxj = js;
    <span class="kw">do</span>{
        <span class="kw">if</span>(cross(pts[(i<span class="dv">+1</span>)%n]-pts[i],
                 pts[(j<span class="dv">+1</span>)%n]-pts[j]) &gt;= <span class="dv">0</span>){
            j = (j<span class="dv">+1</span>)%n;
        }<span class="kw">else</span>{
            i = (i<span class="dv">+1</span>)%n;
        }
        <span class="kw">if</span>(abs(pts[i]-pts[j]) &gt; maxd){
            maxd = abs(pts[i]-pts[j]);
            maxi = i;maxj = j;
        }
    } <span class="kw">while</span>(<span class="kw">not</span>(i == is <span class="kw">and</span> j == js));
    <span class="co">// pts[maxi],pts[maxj] is pair of max diff.</span>
    <span class="kw">return</span> maxd;
}

<span class="co">// 円と円の交点(2点ある前提)</span>
vector&lt;point&gt; circles_point(point c1,<span class="dt">double</span> r1,point c2,<span class="dt">double</span> r2){
    <span class="dt">double</span> d = abs(c1-c2);
    <span class="dt">double</span> s = (r1+r2+d) / <span class="dv">2</span>;
    <span class="dt">double</span> S = sqrt(s*(s-r1)*(s-r2)*(s-d));
    <span class="dt">double</span> h = <span class="dv">2</span> * S / d;
    point v = (c2-c1) / (abs(c2-c1));

    <span class="dt">double</span> m = sqrt(r1*r1 - h*h);

    vector&lt;point&gt; ret;
    ret.push_back(c1 + m*v+h*v*point(<span class="dv">0</span>,<span class="dv">1</span>));
    ret.push_back(c1 + m*v-h*v*point(<span class="dv">0</span>,<span class="dv">1</span>));
    <span class="kw">return</span> ret;
}

<span class="co">// clockwiseだと負</span>
<span class="dt">double</span> triangle_area(point a,point b,point c){
    <span class="kw">return</span> cross(b-a,c-a)/<span class="dv">2</span>;
}

<span class="co">// clockwiseだと負</span>
<span class="dt">double</span> vertex_area(vector&lt;point&gt; v){
    <span class="dt">double</span> ret = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;v.size()<span class="dv">-1</span>;i++){
        ret += triangle_area(v[<span class="dv">0</span>],v[i],v[i<span class="dv">+1</span>]);
    }
    <span class="kw">return</span> ret;
}</code></pre></div>
<h2 id="最近点対"><span class="header-section-number">12.1</span> 最近点対</h2>
<div class="sourceCode" include="cpp/closest_pair_of_points.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;complex&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>


<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">double</span> INF = <span class="fl">1e9</span>;
<span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; point;
<span class="dt">double</span> sub_closest_pair_in_field(<span class="dt">const</span> vector&lt;point&gt; &amp;ps){
    <span class="dt">int</span> N = ps.size();
    <span class="kw">if</span>(N &lt;= <span class="dv">3</span>){
        <span class="dt">double</span> ret = INF;
        <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;ps.size();i++){
            <span class="kw">for</span>(size_t j=i<span class="dv">+1</span>;j&lt;ps.size();j++){
                ret = min(ret,abs(ps[i]-ps[j]));
            }
        }
        <span class="kw">return</span> ret;
    }

    point middle = ps[N/<span class="dv">2</span>];
    vector&lt;point&gt; left(ps.begin(),ps.begin()+N/<span class="dv">2</span>);
    vector&lt;point&gt; right(ps.begin()+N/<span class="dv">2+1</span>,ps.end());

    <span class="dt">double</span> d = min(sub_closest_pair_in_field(left),
                   sub_closest_pair_in_field(right));

    vector&lt;point&gt; strip;
    <span class="kw">for</span>(<span class="dt">const</span> point&amp; p : ps){
        <span class="kw">if</span>(abs(middle.real()-p.real()) &lt; d){
            strip.push_back(p);
        }
    }
    sort(strip.begin(),strip.end(),[](<span class="dt">const</span> complex&lt;<span class="dt">double</span>&gt;&amp; lhs,
                                      <span class="dt">const</span> complex&lt;<span class="dt">double</span>&gt;&amp; rhs){
                                          <span class="kw">return</span> lhs.imag() &lt; rhs.imag();
                                      });

    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;strip.size();i++){
        <span class="kw">for</span>(size_t j=i<span class="dv">+1</span>;j&lt;strip.size() <span class="kw">and</span>
                         (strip[j].imag() - strip[i].imag()) &lt; d;j++){
            d = min(d,abs(strip[i]-strip[j]));
        }
    }
    <span class="kw">return</span> d;
}

<span class="co">// find closest pair in field.return distance.</span>
<span class="co">//  O(nlogn) http://www.geeksforgeeks.org/closest-pair-of-points/</span>
<span class="dt">double</span> closest_pair_in_field(vector&lt;point&gt; ps){
    sort(ps.begin(),ps.end(),[](<span class="dt">const</span> complex&lt;<span class="dt">double</span>&gt;&amp; lhs,
                                <span class="dt">const</span> complex&lt;<span class="dt">double</span>&gt;&amp; rhs){
                                    <span class="kw">return</span> lhs.real() &lt; rhs.real();
                                });
    <span class="kw">return</span> sub_closest_pair_in_field(ps);
}

<span class="dt">int</span> main(){
    <span class="dt">int</span> n;cin &gt;&gt; n;
    vector&lt;point&gt; ps(n);
    repeat(i,n){
        <span class="dt">double</span> x,y;
        cin &gt;&gt; x &gt;&gt; y;
        ps[i].real(x);
        ps[i].imag(y);
    }

    cout &lt;&lt; fixed &lt;&lt; setprecision(<span class="dv">10</span>);
    cout &lt;&lt; closest_pair_in_field(ps) &lt;&lt; endl;
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="ゲーム"><span class="header-section-number">13</span> ゲーム</h1>
<h2 id="nim"><span class="header-section-number">13.1</span> Nim</h2>
<p>いくつかのコインの山がある。この中からプレイヤーは山を一つ選び、1個以上の任意の<br />
数のコインを取る。最後のコインを取ったプレイヤーが勝ちである。この問題に<br />
対しては以下のことが知られている。すべての山のxorをとったとき、それが0で<br />
あるとき、後攻の勝ち、それ以外のときは先攻の勝ち。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(){
    <span class="dt">int</span> xor_sum = <span class="dv">0</span>;
    vector&lt;<span class="dt">int</span>&gt; coins = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};
    <span class="kw">for</span>(size_t i=<span class="dv">0</span>;i&lt;coins.size();i++){
        xor_sum = xor_sum ^ coins[i];
    }
    <span class="kw">if</span>(xor_sum != <span class="dv">0</span>) cout &lt;&lt; <span class="st">&quot;First Player Win&quot;</span> &lt;&lt; endl;
    <span class="kw">else</span> cout &lt;&lt; <span class="st">&quot;Second Player Win&quot;</span> &lt;&lt; endl;
}</code></pre></div>
<h1 id="なんか最適化とか"><span class="header-section-number">14</span> なんか最適化とか</h1>
<h2 id="焼き鈍し"><span class="header-section-number">14.1</span> 焼き鈍し</h2>
<p><a href="http://shindannin.hatenadiary.com/entry/20121224/1356364040" class="uri">http://shindannin.hatenadiary.com/entry/20121224/1356364040</a></p>
<div class="sourceCode" include="cpp/sa.cpp"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;chrono&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="ot">#define debug(x) #x &lt;&lt; &quot;=&quot; &lt;&lt; (x)</span>
<span class="ot">#define dump(x) std::cerr &lt;&lt; debug(x) &lt;&lt; &quot; (L:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl</span>

<span class="dt">unsigned</span> <span class="dt">long</span> xor128(){
    <span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">long</span> x=<span class="dv">123456789</span>,y=<span class="dv">362436069</span>,z=<span class="dv">521288629</span>,w=<span class="dv">88675123</span>;
    <span class="dt">unsigned</span> <span class="dt">long</span> t;
    t=(x^(x&lt;&lt;<span class="dv">11</span>));x=y;y=z;z=w; <span class="kw">return</span>( w=(w^(w&gt;&gt;<span class="dv">19</span>))^(t^(t&gt;&gt;<span class="dv">8</span>)) );
}

<span class="dt">signed</span> main() {
    ios::sync_with_stdio(<span class="kw">false</span>);
    cin.tie(<span class="dv">0</span>);

    <span class="dt">const</span> chrono::milliseconds annealing_time(<span class="dv">2000</span>);
    <span class="dt">const</span> <span class="kw">auto</span> start_time = chrono::system_clock::now();
    <span class="dt">const</span> <span class="kw">auto</span> end_time = start_time + annealing_time;
    <span class="dt">const</span> <span class="dt">int</span> precision_for_force_next = <span class="dv">1000000</span>;
    <span class="kw">auto</span> current_time = start_time;

    <span class="dt">const</span> <span class="kw">auto</span> score = [](<span class="dt">double</span> x){
        <span class="kw">return</span> max(-pow(-x<span class="dv">+100</span>,<span class="dv">2</span>)<span class="dv">+100</span>,-pow(-x<span class="dv">+333</span>,<span class="dv">2</span>)<span class="dv">+333</span>);
    };

    <span class="kw">auto</span> current_state = <span class="fl">0.0</span>;     <span class="co">// initial state</span>
    <span class="kw">auto</span> current_score = score(current_state);
    <span class="kw">auto</span> best_state = current_state;
    <span class="kw">auto</span> best_score = current_score;

    <span class="co">// chrono::system_clock should NOT be called many times...</span>
    <span class="kw">while</span>((current_time=chrono::system_clock::now()) &lt; end_time){
        <span class="dt">const</span> <span class="kw">auto</span> progress = <span class="fl">1.0</span>*(current_time-start_time)/(end_time-start_time);
        <span class="dt">const</span> <span class="dt">bool</span> force_next = progress*precision_for_force_next
                              &lt; xor128()%precision_for_force_next;

        <span class="co">// [0..100] -&gt; [-50..50] balance is IMPORTANT.</span>
        <span class="dt">const</span> <span class="kw">auto</span> next_state = current_state + xor128()%<span class="dv">101-50</span>;
        <span class="dt">const</span> <span class="kw">auto</span> next_score = score(next_state);
        <span class="kw">if</span>(force_next <span class="kw">or</span> (next_score &gt; current_score)){
            current_state = next_state;
            current_score = next_score;
            dump(current_state);
            dump(current_score);
        }<span class="kw">else</span>{
            <span class="co">// undo change.</span>
        }

        <span class="kw">if</span>(current_score &gt; best_score){
            best_score = current_score;
            best_state = current_state;
            dump(best_score);
        }
    }
    dump(best_score);
    dump(best_state);

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="いろんなデータ"><span class="header-section-number">15</span> いろんなデータ</h1>
<h2 id="階乗"><span class="header-section-number">15.1</span> 階乗</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><span class="math inline">\(N\)</span></th>
<th style="text-align: left;"><span class="math inline">\(N!\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">24</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">120</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">720</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">5040</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">40320</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">362880</td>
</tr>
<tr class="odd">
<td style="text-align: left;">10</td>
<td style="text-align: left;">3628800</td>
</tr>
</tbody>
</table>
<h2 id="数単位変換"><span class="header-section-number">15.2</span> 数単位変換</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">N</th>
<th style="text-align: left;">日本語</th>
<th style="text-align: center;">英語</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{0}\)</span></td>
<td style="text-align: left;">一</td>
<td style="text-align: center;">one</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{1}\)</span></td>
<td style="text-align: left;">十</td>
<td style="text-align: center;">ten</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{2}\)</span></td>
<td style="text-align: left;">百</td>
<td style="text-align: center;">hundred</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{3}\)</span></td>
<td style="text-align: left;">千</td>
<td style="text-align: center;">thousand</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{4}\)</span></td>
<td style="text-align: left;">万</td>
<td style="text-align: center;">ten thousand</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{5}\)</span></td>
<td style="text-align: left;">十万</td>
<td style="text-align: center;">hundred thousand</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{6}\)</span></td>
<td style="text-align: left;">百万</td>
<td style="text-align: center;">million</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{7}\)</span></td>
<td style="text-align: left;">千万</td>
<td style="text-align: center;">ten million</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{8}\)</span></td>
<td style="text-align: left;">億</td>
<td style="text-align: center;">hundred million</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{9}\)</span></td>
<td style="text-align: left;">十億</td>
<td style="text-align: center;">billion</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(10^{10}\)</span></td>
<td style="text-align: left;">百億</td>
<td style="text-align: center;">ten billion</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(10^{11}\)</span></td>
<td style="text-align: left;">千億</td>
<td style="text-align: center;">hundred billion</td>
</tr>
</tbody>
</table>
<h2 id="bit"><span class="header-section-number">15.3</span> bit</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">N</th>
<th style="text-align: left;"><span class="math inline">\(2^N\)</span></th>
<th style="text-align: left;">備考</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">boolの大きさ</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">128</td>
<td style="text-align: left;">charの最大値+1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">256</td>
<td style="text-align: left;">unsigned charの最大値+1</td>
</tr>
<tr class="even">
<td style="text-align: left;">16</td>
<td style="text-align: left;">65,534</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">24</td>
<td style="text-align: left;">16,777,216</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">31</td>
<td style="text-align: left;">2,147,483,648</td>
<td style="text-align: left;">intの最大値+1(about 2*10^9)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">32</td>
<td style="text-align: left;">4,294,967,296</td>
<td style="text-align: left;">unsigned intの最大値+1</td>
</tr>
<tr class="even">
<td style="text-align: left;">52</td>
<td style="text-align: left;">4,503,599,627,370,496</td>
<td style="text-align: left;">doubleのprecision</td>
</tr>
<tr class="odd">
<td style="text-align: left;">63</td>
<td style="text-align: left;">9,223,372,036,854,775,808</td>
<td style="text-align: left;">long longの最大値+1</td>
</tr>
<tr class="even">
<td style="text-align: left;">64</td>
<td style="text-align: left;">18,446,744,073,709,551,616</td>
<td style="text-align: left;">unsigned long longの最大値+1(about 10^19)</td>
</tr>
</tbody>
</table>
<h2 id="最低限の設定ファイル"><span class="header-section-number">15.4</span> 最低限の設定ファイル</h2>
<h3 id="vim用"><span class="header-section-number">15.4.1</span> vim用</h3>
<p>最低限のもの。ホームにおく。</p>
<pre><code>set fileencoding=utf-8
set nocompatible
set t_Co=256
set ambiwidth=double

syntax on
filetype plugin indent on

set nobackup
set noswapfile

set completeopt=menuone
set wildmode=list:longest

set smartindent
set autoindent
set tabstop=4
set softtabstop=4
set shiftwidth=4

set smarttab
set expandtab

set incsearch ignorecase hlsearch
set showmatch
set wildmenu

set listchars=tab:&gt;-,trail:-
set list

set backspace=indent,eol,start</code></pre>
<!-- 
## アスキーコード


Char   Dec    Oct    Hex
------ ------ ------ ------
(nul)    0     0000   0x00
(soh)    1     0001   0x01
(stx)    2     0002   0x02
(etx)    3     0003   0x03
(eot)    4     0004   0x04
(enq)    5     0005   0x05
(ack)    6     0006   0x06
(bel)    7     0007   0x07
(bs)     8     0010   0x08
(ht)     9     0011   0x09
(nl)    10     0012   0x0a
(vt)    11     0013   0x0b
(np)    12     0014   0x0c
(cr)    13     0015   0x0d
(so)    14     0016   0x0e
(si)    15     0017   0x0f
(dle)   16     0020   0x10
(dc1)   17     0021   0x11
(dc2)   18     0022   0x12
(dc3)   19     0023   0x13
(dc4)   20     0024   0x14
(nak)   21     0025   0x15
(syn)   22     0026   0x16
(etb)   23     0027   0x17
(can)   24     0030   0x18
(em)    25     0031   0x19
(sub)   26     0032   0x1a
(esc)   27     0033   0x1b
(fs)    28     0034   0x1c
(gs)    29     0035   0x1d
(rs)    30     0036   0x1e
(us)    31     0037   0x1f
(sp)    32     0040   0x20
!       33     0041   0x21
"       34     0042   0x22
#       35     0043   0x23
$       36     0044   0x24
%       37     0045   0x25
&       38     0046   0x26
'       39     0047   0x27
(       40     0050   0x28
)       41     0051   0x29
*       42     0052   0x2a
+       43     0053   0x2b
,       44     0054   0x2c
-       45     0055   0x2d
.       46     0056   0x2e
/       47     0057   0x2f
0       48     0060   0x30
1       49     0061   0x31
2       50     0062   0x32
3       51     0063   0x33
4       52     0064   0x34
5       53     0065   0x35
6       54     0066   0x36
7       55     0067   0x37
8       56     0070   0x38
9       57     0071   0x39
:       58     0072   0x3a
;       59     0073   0x3b
<       60     0074   0x3c
=       61     0075   0x3d
>       62     0076   0x3e
?       63     0077   0x3f
@       64     0100   0x40
A       65     0101   0x41
B       66     0102   0x42
C       67     0103   0x43
D       68     0104   0x44
E       69     0105   0x45
F       70     0106   0x46
G       71     0107   0x47
H       72     0110   0x48
I       73     0111   0x49
J       74     0112   0x4a
K       75     0113   0x4b
L       76     0114   0x4c
M       77     0115   0x4d
N       78     0116   0x4e
O       79     0117   0x4f
P       80     0120   0x50
Q       81     0121   0x51
R       82     0122   0x52
S       83     0123   0x53
T       84     0124   0x54
U       85     0125   0x55
V       86     0126   0x56
W       87     0127   0x57
X       88     0130   0x58
Y       89     0131   0x59
Z       90     0132   0x5a
[       91     0133   0x5b
\       92     0134   0x5c
]       93     0135   0x5d
^       94     0136   0x5e
_       95     0137   0x5f
`       96     0140   0x60
a       97     0141   0x61
b       98     0142   0x62
c       99     0143   0x63
d      100     0144   0x64
e      101     0145   0x65
f      102     0146   0x66
g      103     0147   0x67
h      104     0150   0x68
i      105     0151   0x69
j      106     0152   0x6a
k      107     0153   0x6b
l      108     0154   0x6c
m      109     0155   0x6d
n      110     0156   0x6e
o      111     0157   0x6f
p      112     0160   0x70
q      113     0161   0x71
r      114     0162   0x72
s      115     0163   0x73
t      116     0164   0x74
u      117     0165   0x75
v      118     0166   0x76
w      119     0167   0x77
x      120     0170   0x78
y      121     0171   0x79
z      122     0172   0x7a
{      123     0173   0x7b
|      124     0174   0x7c
}      125     0175   0x7d
~      126     0176   0x7e
(del)  127     0177   0x7f
-->
</body>
</html>
